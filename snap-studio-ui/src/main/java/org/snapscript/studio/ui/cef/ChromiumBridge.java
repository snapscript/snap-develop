package org.snapscript.studio.ui.cef;
// Generated by ffi_gen. Please do not change this file by hand.

import java.lang.annotation.Annotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;

import jnr.ffi.LibraryLoader;
import jnr.ffi.LibraryOption;
import jnr.ffi.Struct;
import jnr.ffi.Union;
import jnr.ffi.annotations.Delegate;
import jnr.ffi.mapper.FunctionMapper;
import jnr.ffi.provider.ParameterFlags;
import jnr.ffi.util.EnumMapper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.snapscript.studio.ui.jnr.ffi.InnerStruct;
import org.snapscript.studio.ui.jnr.ffi.InnerStructToNativeConverter;

public class ChromiumBridge {
   
   private static final Logger LOG = LoggerFactory.getLogger(ChromiumBridge.class);
   
    public static CEFInterface INSTANCE = CEFInterface.InstanceCreator.createInstance();
    public static jnr.ffi.Runtime RUNTIME;
    
    /*interface NativeEnum {
        public int toNativeInt();
    }*/
    /*
    static Pointer bytesToPointer(byte[] b) {
        Pointer p = Memory.allocate(RUNTIME, b.length);
        p.write(0, b, 0, b.length);
        return p;
    }
    */
    
    public static int STRING_TYPE_UTF16 = 1;
    
    public static int K_NULL_CURSOR_HANDLE = 0;
    
    public static int K_NULL_WINDOW_HANDLE = 0;
    
    /**
     * (Not documented)
     */
    public static final class XEvent extends Union {
        // hidden structure
        public XEvent(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     */
    public static final class XDisplay extends Struct {
        // hidden structure
        public XDisplay(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :str ::
     *   (FFI::Pointer(*Wchar)) 
     * :length ::
     *   (Integer) 
     * :dtor ::
     *   (Function(Dtor)) 
     */
    public static final class StringWide extends Struct {
        public Pointer str = new Pointer();
        public UnsignedLong length = new UnsignedLong();
        public Function<Dtor> dtor = function(Dtor.class);
        public static interface Dtor {
            @Delegate
            void invoke(jnr.ffi.Pointer int_);
        }
        public void setDtor(Dtor callback) {
            dtor.set(callback);
        }
        
        public StringWide(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :str ::
     *   (String) 
     * :length ::
     *   (Integer) 
     * :dtor ::
     *   (Function(Dtor)) 
     */
    public static final class StringUtf8 extends InnerStruct {
        public UTF8StringRef str = new UTF8StringRef(100);
        public UnsignedLong length = new UnsignedLong();
        public Function<Dtor> dtor = function(Dtor.class);
        public static interface Dtor {
            @Delegate
            void invoke(String string);
        }
        public void setDtor(Dtor callback) {
            dtor.set(callback);
        }
        
        public StringUtf8(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :str ::
     *   (FFI::Pointer(*Char16)) 
     * :length ::
     *   (Integer) 
     * :dtor ::
     *   (Function(Dtor)) 
     */
    public static final class StringUtf16 extends InnerStruct {
        public Pointer str = new Pointer();
        public UnsignedLong length = new UnsignedLong();
        public Function<Dtor> dtor = function(Dtor.class);
        public static interface Dtor {
            @Delegate
            void invoke(jnr.ffi.Pointer uShort);
        }
        public void setDtor(Dtor callback) {
            dtor.set(callback);
        }
        
        public StringUtf16(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
		public void set(java.lang.String v) {
//			str.set(v);
//			length.set(v.length());
			if (INSTANCE.stringUtf8ToUtf16(v, v.length(), this) != 1)
				throw new RuntimeException("Could not set StringUtf16");
		}
		
		public class UTF16StringRef extends UTFStringRef {

			public UTF16StringRef(int length) {
				super(length, UTF16);
			}
			
			public java.lang.String getUtf() {
				LOG.info("getUtf");
				
				jnr.ffi.Pointer memory = getStringMemory();
				byte[] bytes = new byte[length];
				memory.get(0, bytes, 0, length);

				// find the null terminator first
				int nullPos = bytes.length;
				for (int i = 0; i < nullPos; i += 2) {
					if (bytes[i] == 0 && bytes[i + 1] == 0) {
						nullPos = i;
						break;
					}
				}
				CharBuffer res = charset.decode(ByteBuffer.wrap(bytes, 0, nullPos));
				return res.toString();
			}
		}
    }
    
    static Charset UTF16 = Charset.forName("UTF-16");
    
    /**
     * (Not documented)
     * 
     * @method stringWideSet(src, srcLen, output, copy)
     * @param [FFI::Pointer(*Wchar)] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @param [Integer] copy 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideSet(jnr.ffi.Pointer src, long srcLen, StringWide output, int copy) {
        return INSTANCE.stringWideSet(src, srcLen, output, copy);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8Set(src, srcLen, output, copy)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringUtf8] output 
     * @param [Integer] copy 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8Set(String src, long srcLen, StringUtf8 output, int copy) {
        return INSTANCE.stringUtf8Set(src, srcLen, output, copy);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16Set(src, srcLen, output, copy)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @param [Integer] copy 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16Set(jnr.ffi.Pointer src, long srcLen, StringUtf16 output, int copy) {
        return INSTANCE.stringUtf16Set(src, srcLen, output, copy);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideClear(str)
     * @param [StringWide] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringWideClear(StringWide str) {
        INSTANCE.stringWideClear(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8Clear(str)
     * @param [StringUtf8] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUtf8Clear(StringUtf8 str) {
        INSTANCE.stringUtf8Clear(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16Clear(str)
     * @param [StringUtf16] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUtf16Clear(StringUtf16 str) {
        INSTANCE.stringUtf16Clear(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideCmp(str1, str2)
     * @param [StringWide] str1 
     * @param [StringWide] str2 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideCmp(StringWide str1, StringWide str2) {
        return INSTANCE.stringWideCmp(str1, str2);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8Cmp(str1, str2)
     * @param [StringUtf8] str1 
     * @param [StringUtf8] str2 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8Cmp(StringUtf8 str1, StringUtf8 str2) {
        return INSTANCE.stringUtf8Cmp(str1, str2);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16Cmp(str1, str2)
     * @param [StringUtf16] str1 
     * @param [StringUtf16] str2 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16Cmp(StringUtf16 str1, StringUtf16 str2) {
        return INSTANCE.stringUtf16Cmp(str1, str2);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideToUtf8(src, srcLen, output)
     * @param [FFI::Pointer(*Wchar)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf8] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideToUtf8(jnr.ffi.Pointer src, long srcLen, StringUtf8 output) {
        return INSTANCE.stringWideToUtf8(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8ToWide(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8ToWide(String src, long srcLen, StringWide output) {
        return INSTANCE.stringUtf8ToWide(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringWideToUtf16(src, srcLen, output)
     * @param [FFI::Pointer(*Wchar)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringWideToUtf16(jnr.ffi.Pointer src, long srcLen, StringUtf16 output) {
        return INSTANCE.stringWideToUtf16(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16ToWide(src, srcLen, output)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16ToWide(jnr.ffi.Pointer src, long srcLen, StringWide output) {
        return INSTANCE.stringUtf16ToWide(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf8ToUtf16(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf8ToUtf16(String src, long srcLen, StringUtf16 output) {
        return INSTANCE.stringUtf8ToUtf16(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16ToUtf8(src, srcLen, output)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf8] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16ToUtf8(jnr.ffi.Pointer src, long srcLen, StringUtf8 output) {
        return INSTANCE.stringUtf16ToUtf8(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringAsciiToWide(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringWide] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringAsciiToWide(String src, long srcLen, StringWide output) {
        return INSTANCE.stringAsciiToWide(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringAsciiToUtf16(src, srcLen, output)
     * @param [String] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringAsciiToUtf16(String src, long srcLen, StringUtf16 output) {
        return INSTANCE.stringAsciiToUtf16(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeWideAlloc()
     * @return [StringWide] 
     * @scope class
     */
    public static StringWide stringUserfreeWideAlloc() {
        return INSTANCE.stringUserfreeWideAlloc();
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf8Alloc()
     * @return [StringUtf8] 
     * @scope class
     */
    public static StringUtf8 stringUserfreeUtf8Alloc() {
        return INSTANCE.stringUserfreeUtf8Alloc();
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf16Alloc()
     * @return [StringUtf16] 
     * @scope class
     */
    public static StringUtf16 stringUserfreeUtf16Alloc() {
        return INSTANCE.stringUserfreeUtf16Alloc();
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeWideFree(str)
     * @param [StringWide] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUserfreeWideFree(StringWide str) {
        INSTANCE.stringUserfreeWideFree(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf8Free(str)
     * @param [StringUtf8] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUserfreeUtf8Free(StringUtf8 str) {
        INSTANCE.stringUserfreeUtf8Free(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUserfreeUtf16Free(str)
     * @param [StringUtf16] str 
     * @return [nil] 
     * @scope class
     */
    public static void stringUserfreeUtf16Free(StringUtf16 str) {
        INSTANCE.stringUserfreeUtf16Free(str);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16ToLower(src, srcLen, output)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16ToLower(jnr.ffi.Pointer src, long srcLen, StringUtf16 output) {
        return INSTANCE.stringUtf16ToLower(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method stringUtf16ToUpper(src, srcLen, output)
     * @param [FFI::Pointer(*Char16)] src 
     * @param [Integer] srcLen 
     * @param [StringUtf16] output 
     * @return [Integer] 
     * @scope class
     */
    public static int stringUtf16ToUpper(jnr.ffi.Pointer src, long srcLen, StringUtf16 output) {
        return INSTANCE.stringUtf16ToUpper(src, srcLen, output);
    }
    
    /**
     * (Not documented)
     * 
     * @method getXdisplay()
     * @return [XDisplay] 
     * @scope class
     */
    public static XDisplay getXdisplay() {
        return INSTANCE.getXdisplay();
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :argc ::
     *   (Integer) 
     * :argv ::
     *   (FFI::Pointer(**CharS)) 
     */
    public static final class MainArgs extends Struct {
        public Signed32 argc = new Signed32();
        public Pointer argv = new Pointer();
        public MainArgs(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     * :width ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     * :parentWindow ::
     *   (Integer) 
     * :windowlessRenderingEnabled ::
     *   (Integer) Set to true (1) to create the browser using windowless (off-screen)
     *   rendering. No window will be created for the browser and all rendering will
     *   occur via the CefRenderHandler interface. The |parent_window| value will be
     *   used to identify monitor info and to act as the parent window for dialogs,
     *   context menus, etc. If |parent_window| is not provided then the main screen
     *   monitor will be used and some functionality that requires a parent window
     *   may not function correctly. In order to create windowless browsers the
     *   CefSettings.windowless_rendering_enabled value must be set to true.
     * :transparentPaintingEnabled ::
     *   (Integer) Set to true (1) to enable transparent painting in combination with
     *   windowless rendering. When this value is true a transparent background
     *   color will be used (RGBA=0x00000000). When this value is false the
     *   background will be white and opaque.
     * :window ::
     *   (Integer) 
     */
    public static final class WindowInfo extends Struct {
        public Unsigned32 x = new Unsigned32();
        public Unsigned32 y = new Unsigned32();
        public Unsigned32 width = new Unsigned32();
        public Unsigned32 height = new Unsigned32();
        public UnsignedLong parentWindow = new UnsignedLong();
        public Signed32 windowlessRenderingEnabled = new Signed32();
        public Signed32 transparentPaintingEnabled = new Signed32();
        public UnsignedLong window = new UnsignedLong();
        public WindowInfo(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:LogSeverity).</em>
     * 
     * === Options:
     * LOGSEVERITY_DEFAULT ::
     *   Default logging (currently INFO logging).
     * LOGSEVERITY_VERBOSE ::
     *   Verbose logging.
     * LOGSEVERITY_INFO ::
     *   INFO logging.
     * LOGSEVERITY_WARNING ::
     *   WARNING logging.
     * LOGSEVERITY_ERROR ::
     *   ERROR logging.
     * LOGSEVERITY_DISABLE ::
     *   Completely disable logging.
     * 
     * @method _enum_LogSeverity_
     * @return [Symbol]
     * @scope class
     */
    public enum LogSeverity implements EnumMapper.IntegerEnum {
        LOGSEVERITY_DEFAULT(0),
        LOGSEVERITY_VERBOSE(1),
        LOGSEVERITY_INFO(2),
        LOGSEVERITY_WARNING(3),
        LOGSEVERITY_ERROR(4),
        LOGSEVERITY_DISABLE(99)
        ;
        
        private int nativeInt;
        
        private LogSeverity(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:State).</em>
     * 
     * === Options:
     * DEFAULT ::
     *   Use the default state for the setting.
     * ENABLED ::
     *   Enable or allow the setting.
     * DISABLED ::
     *   Disable or disallow the setting.
     * 
     * @method _enum_State_
     * @return [Symbol]
     * @scope class
     */
    public enum State implements EnumMapper.IntegerEnum {
        DEFAULT(0),
        ENABLED(1),
        DISABLED(2)
        ;
        
        private int nativeInt;
        
        private State(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of this structure.
     * :singleProcess ::
     *   (Integer) Set to true (1) to use a single process for the browser and renderer. This
     *   run mode is not officially supported by Chromium and is less stable than
     *   the multi-process default. Also configurable using the "single-process"
     *   command-line switch.
     * :noSandbox ::
     *   (Integer) Set to true (1) to disable the sandbox for sub-processes. See
     *   cef_sandbox_win.h for requirements to enable the sandbox on Windows. Also
     *   configurable using the "no-sandbox" command-line switch.
     * :browserSubprocessPath ::
     *   (StringUtf16) The path to a separate executable that will be launched for sub-processes.
     *   If this value is empty on Windows or Linux then the main process executable
     *   will be used. If this value is empty on macOS then a helper executable must
     *   exist at "Contents/Frameworks/<app> Helper.app/Contents/MacOS/<app> Helper"
     *   in the top-level app bundle. See the comments on CefExecuteProcess() for
     *   details. Also configurable using the "browser-subprocess-path" command-line
     *   switch.
     * :frameworkDirPath ::
     *   (StringUtf16) The path to the CEF framework directory on macOS. If this value is empty
     *   then the framework must exist at "Contents/Frameworks/Chromium Embedded
     *   Framework.framework" in the top-level app bundle. Also configurable using
     *   the "framework-dir-path" command-line switch.
     * :multiThreadedMessageLoop ::
     *   (Integer) Set to true (1) to have the browser process message loop run in a separate
     *   thread. If false (0) than the CefDoMessageLoopWork() function must be
     *   called from your application message loop. This option is only supported on
     *   Windows.
     * :externalMessagePump ::
     *   (Integer) Set to true (1) to control browser process main (UI) thread message pump
     *   scheduling via the CefBrowserProcessHandler::OnScheduleMessagePumpWork()
     *   callback. This option is recommended for use in combination with the
     *   CefDoMessageLoopWork() function in cases where the CEF message loop must be
     *   integrated into an existing application message loop (see additional
     *   comments and warnings on CefDoMessageLoopWork). Enabling this option is not
     *   recommended for most users; leave this option disabled and use either the
     *   CefRunMessageLoop() function or multi_threaded_message_loop if possible.
     * :windowlessRenderingEnabled ::
     *   (Integer) Set to true (1) to enable windowless (off-screen) rendering support. Do not
     *   enable this value if the application does not use windowless rendering as
     *   it may reduce rendering performance on some systems.
     * :commandLineArgsDisabled ::
     *   (Integer) Set to true (1) to disable configuration of browser process features using
     *   standard CEF and Chromium command-line arguments. Configuration can still
     *   be specified using CEF data structures or via the
     *   CefApp::OnBeforeCommandLineProcessing() method.
     * :cachePath ::
     *   (StringUtf16) The location where cache data will be stored on disk. If empty then
     *   browsers will be created in "incognito mode" where in-memory caches are
     *   used for storage and no data is persisted to disk. HTML5 databases such as
     *   localStorage will only persist across sessions if a cache path is
     *   specified. Can be overridden for individual CefRequestContext instances via
     *   the CefRequestContextSettings.cache_path value.
     * :userDataPath ::
     *   (StringUtf16) The location where user data such as spell checking dictionary files will
     *   be stored on disk. If empty then the default platform-specific user data
     *   directory will be used ("~/.cef_user_data" directory on Linux,
     *   "~/Library/Application Support/CEF/User Data" directory on Mac OS X,
     *   "Local Settings\Application Data\CEF\User Data" directory under the user
     *   profile directory on Windows).
     * :persistSessionCookies ::
     *   (Integer) To persist session cookies (cookies without an expiry date or validity
     *   interval) by default when using the global cookie manager set this value to
     *   true (1). Session cookies are generally intended to be transient and most
     *   Web browsers do not persist them. A |cache_path| value must also be
     *   specified to enable this feature. Also configurable using the
     *   "persist-session-cookies" command-line switch. Can be overridden for
     *   individual CefRequestContext instances via the
     *   CefRequestContextSettings.persist_session_cookies value.
     * :persistUserPreferences ::
     *   (Integer) To persist user preferences as a JSON file in the cache path directory set
     *   this value to true (1). A |cache_path| value must also be specified
     *   to enable this feature. Also configurable using the
     *   "persist-user-preferences" command-line switch. Can be overridden for
     *   individual CefRequestContext instances via the
     *   CefRequestContextSettings.persist_user_preferences value.
     * :userAgent ::
     *   (StringUtf16) Value that will be returned as the User-Agent HTTP header. If empty the
     *   default User-Agent string will be used. Also configurable using the
     *   "user-agent" command-line switch.
     * :productVersion ::
     *   (StringUtf16) Value that will be inserted as the product portion of the default
     *   User-Agent string. If empty the Chromium product version will be used. If
     *   |userAgent| is specified this value will be ignored. Also configurable
     *   using the "product-version" command-line switch.
     * :locale ::
     *   (StringUtf16) The locale string that will be passed to WebKit. If empty the default
     *   locale of "en-US" will be used. This value is ignored on Linux where locale
     *   is determined using environment variable parsing with the precedence order:
     *   LANGUAGE, LC_ALL, LC_MESSAGES and LANG. Also configurable using the "lang"
     *   command-line switch.
     * :logFile ::
     *   (StringUtf16) The directory and file name to use for the debug log. If empty a default
     *   log file name and location will be used. On Windows and Linux a "debug.log"
     *   file will be written in the main executable directory. On Mac OS X a
     *   "~/Library/Logs/<app name>_debug.log" file will be written where <app name>
     *   is the name of the main app executable. Also configurable using the
     *   "log-file" command-line switch.
     * :logSeverity ::
     *   (Symbol from _enum_LogSeverity_) The log severity. Only messages of this severity level or higher will be
     *   logged. Also configurable using the "log-severity" command-line switch with
     *   a value of "verbose", "info", "warning", "error", "error-report" or
     *   "disable".
     * :javascriptFlags ::
     *   (StringUtf16) Custom flags that will be used when initializing the V8 JavaScript engine.
     *   The consequences of using custom flags may not be well tested. Also
     *   configurable using the "js-flags" command-line switch.
     * :resourcesDirPath ::
     *   (StringUtf16) The fully qualified path for the resources directory. If this value is
     *   empty the cef.pak and/or devtools_resources.pak files must be located in
     *   the module directory on Windows/Linux or the app bundle Resources directory
     *   on Mac OS X. Also configurable using the "resources-dir-path" command-line
     *   switch.
     * :localesDirPath ::
     *   (StringUtf16) The fully qualified path for the locales directory. If this value is empty
     *   the locales directory must be located in the module directory. This value
     *   is ignored on Mac OS X where pack files are always loaded from the app
     *   bundle Resources directory. Also configurable using the "locales-dir-path"
     *   command-line switch.
     * :packLoadingDisabled ::
     *   (Integer) Set to true (1) to disable loading of pack files for resources and locales.
     *   A resource bundle handler must be provided for the browser and render
     *   processes via CefApp::GetResourceBundleHandler() if loading of pack files
     *   is disabled. Also configurable using the "disable-pack-loading" command-
     *   line switch.
     * :remoteDebuggingPort ::
     *   (Integer) Set to a value between 1024 and 65535 to enable remote debugging on the
     *   specified port. For example, if 8080 is specified the remote debugging URL
     *   will be http://localhost:8080. CEF can be remotely debugged from any CEF or
     *   Chrome browser window. Also configurable using the "remote-debugging-port"
     *   command-line switch.
     * :uncaughtExceptionStackSize ::
     *   (Integer) The number of stack trace frames to capture for uncaught exceptions.
     *   Specify a positive value to enable the CefRenderProcessHandler::
     *   OnUncaughtException() callback. Specify 0 (default value) and
     *   OnUncaughtException() will not be called. Also configurable using the
     *   "uncaught-exception-stack-size" command-line switch.
     * :contextSafetyImplementation ::
     *   (Integer) By default CEF V8 references will be invalidated (the IsValid() method will
     *   return false) after the owning context has been released. This reduces the
     *   need for external record keeping and avoids crashes due to the use of V8
     *   references after the associated context has been released.
     *   
     *   CEF currently offers two context safety implementations with different
     *   performance characteristics. The default implementation (value of 0) uses a
     *   map of hash values and should provide better performance in situations with
     *   a small number contexts. The alternate implementation (value of 1) uses a
     *   hidden value attached to each context and should provide better performance
     *   in situations with a large number of contexts.
     *   
     *   If you need better performance in the creation of V8 references and you
     *   plan to manually track context lifespan you can disable context safety by
     *   specifying a value of -1.
     *   
     *   Also configurable using the "context-safety-implementation" command-line
     *   switch.
     * :ignoreCertificateErrors ::
     *   (Integer) Set to true (1) to ignore errors related to invalid SSL certificates.
     *   Enabling this setting can lead to potential security vulnerabilities like
     *   "man in the middle" attacks. Applications that load content from the
     *   internet should not enable this setting. Also configurable using the
     *   "ignore-certificate-errors" command-line switch. Can be overridden for
     *   individual CefRequestContext instances via the
     *   CefRequestContextSettings.ignore_certificate_errors value.
     * :enableNetSecurityExpiration ::
     *   (Integer) Set to true (1) to enable date-based expiration of built in network
     *   security information (i.e. certificate transparency logs, HSTS preloading
     *   and pinning information). Enabling this option improves network security
     *   but may cause HTTPS load failures when using CEF binaries built more than
     *   10 weeks in the past. See https://www.certificate-transparency.org/ and
     *   https://www.chromium.org/hsts for details. Also configurable using the
     *   "enable-net-security-expiration" command-line switch. Can be overridden for
     *   individual CefRequestContext instances via the
     *   CefRequestContextSettings.enable_net_security_expiration value.
     * :backgroundColor ::
     *   (Integer) Opaque background color used for accelerated content. By default the
     *   background color will be white. Only the RGB compontents of the specified
     *   value will be used. The alpha component must greater than 0 to enable use
     *   of the background color but will be otherwise ignored.
     * :acceptLanguageList ::
     *   (StringUtf16) Comma delimited ordered list of language codes without any whitespace that
     *   will be used in the "Accept-Language" HTTP header. May be overridden on a
     *   per-browser basis using the CefBrowserSettings.accept_language_list value.
     *   If both values are empty then "en-US,en" will be used. Can be overridden
     *   for individual CefRequestContext instances via the
     *   CefRequestContextSettings.accept_language_list value.
     */
    public static final class Settings extends Struct {
        public UnsignedLong size = new UnsignedLong();
        public Signed32 singleProcess = new Signed32();
        public Signed32 noSandbox = new Signed32();
        public StringUtf16 browserSubprocessPath = inner(new StringUtf16(getRuntime()));
        public StringUtf16 frameworkDirPath = inner(new StringUtf16(getRuntime()));
        public Signed32 multiThreadedMessageLoop = new Signed32();
        public Signed32 externalMessagePump = new Signed32();
        public Signed32 windowlessRenderingEnabled = new Signed32();
        public Signed32 commandLineArgsDisabled = new Signed32();
        public StringUtf16 cachePath = inner(new StringUtf16(getRuntime()));
        public StringUtf16 userDataPath = inner(new StringUtf16(getRuntime()));
        public Signed32 persistSessionCookies = new Signed32();
        public Signed32 persistUserPreferences = new Signed32();
        public StringUtf16 userAgent = inner(new StringUtf16(getRuntime()));
        public StringUtf16 productVersion = inner(new StringUtf16(getRuntime()));
        public StringUtf16 locale = inner(new StringUtf16(getRuntime()));
        public StringUtf16 logFile = inner(new StringUtf16(getRuntime()));
        public Enum<LogSeverity> logSeverity = new Enum<>(LogSeverity.class);
        public StringUtf16 javascriptFlags = inner(new StringUtf16(getRuntime()));
        public StringUtf16 resourcesDirPath = inner(new StringUtf16(getRuntime()));
        public StringUtf16 localesDirPath = inner(new StringUtf16(getRuntime()));
        public Signed32 packLoadingDisabled = new Signed32();
        public Signed32 remoteDebuggingPort = new Signed32();
        public Signed32 uncaughtExceptionStackSize = new Signed32();
        public Signed32 contextSafetyImplementation = new Signed32();
        public Signed32 ignoreCertificateErrors = new Signed32();
        public Signed32 enableNetSecurityExpiration = new Signed32();
        public Unsigned32 backgroundColor = new Unsigned32();
        public StringUtf16 acceptLanguageList = inner(new StringUtf16(getRuntime()));
        public Settings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of this structure.
     * :cachePath ::
     *   (StringUtf16) The location where cache data will be stored on disk. If empty then
     *   browsers will be created in "incognito mode" where in-memory caches are
     *   used for storage and no data is persisted to disk. HTML5 databases such as
     *   localStorage will only persist across sessions if a cache path is
     *   specified. To share the global browser cache and related configuration set
     *   this value to match the CefSettings.cache_path value.
     * :persistSessionCookies ::
     *   (Integer) To persist session cookies (cookies without an expiry date or validity
     *   interval) by default when using the global cookie manager set this value to
     *   true (1). Session cookies are generally intended to be transient and most
     *   Web browsers do not persist them. Can be set globally using the
     *   CefSettings.persist_session_cookies value. This value will be ignored if
     *   |cache_path| is empty or if it matches the CefSettings.cache_path value.
     * :persistUserPreferences ::
     *   (Integer) To persist user preferences as a JSON file in the cache path directory set
     *   this value to true (1). Can be set globally using the
     *   CefSettings.persist_user_preferences value. This value will be ignored if
     *   |cache_path| is empty or if it matches the CefSettings.cache_path value.
     * :ignoreCertificateErrors ::
     *   (Integer) Set to true (1) to ignore errors related to invalid SSL certificates.
     *   Enabling this setting can lead to potential security vulnerabilities like
     *   "man in the middle" attacks. Applications that load content from the
     *   internet should not enable this setting. Can be set globally using the
     *   CefSettings.ignore_certificate_errors value. This value will be ignored if
     *   |cache_path| matches the CefSettings.cache_path value.
     * :enableNetSecurityExpiration ::
     *   (Integer) Set to true (1) to enable date-based expiration of built in network
     *   security information (i.e. certificate transparency logs, HSTS preloading
     *   and pinning information). Enabling this option improves network security
     *   but may cause HTTPS load failures when using CEF binaries built more than
     *   10 weeks in the past. See https://www.certificate-transparency.org/ and
     *   https://www.chromium.org/hsts for details. Can be set globally using the
     *   CefSettings.enable_net_security_expiration value.
     * :acceptLanguageList ::
     *   (StringUtf16) Comma delimited ordered list of language codes without any whitespace that
     *   will be used in the "Accept-Language" HTTP header. Can be set globally
     *   using the CefSettings.accept_language_list value or overridden on a per-
     *   browser basis using the CefBrowserSettings.accept_language_list value. If
     *   all values are empty then "en-US,en" will be used. This value will be
     *   ignored if |cache_path| matches the CefSettings.cache_path value.
     */
    public static final class RequestContextSettings extends Struct {
        public UnsignedLong size = new UnsignedLong();
        public StringUtf16 cachePath = inner(new StringUtf16(getRuntime()));
        public Signed32 persistSessionCookies = new Signed32();
        public Signed32 persistUserPreferences = new Signed32();
        public Signed32 ignoreCertificateErrors = new Signed32();
        public Signed32 enableNetSecurityExpiration = new Signed32();
        public StringUtf16 acceptLanguageList = inner(new StringUtf16(getRuntime()));
        public RequestContextSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of this structure.
     * :windowlessFrameRate ::
     *   (Integer) The maximum rate in frames per second (fps) that CefRenderHandler::OnPaint
     *   will be called for a windowless browser. The actual fps may be lower if
     *   the browser cannot generate frames at the requested rate. The minimum
     *   value is 1 and the maximum value is 60 (default 30). This value can also be
     *   changed dynamically via CefBrowserHost::SetWindowlessFrameRate.
     * :standardFontFamily ::
     *   (StringUtf16) Font settings.
     * :fixedFontFamily ::
     *   (StringUtf16) 
     * :serifFontFamily ::
     *   (StringUtf16) 
     * :sansSerifFontFamily ::
     *   (StringUtf16) 
     * :cursiveFontFamily ::
     *   (StringUtf16) 
     * :fantasyFontFamily ::
     *   (StringUtf16) 
     * :defaultFontSize ::
     *   (Integer) 
     * :defaultFixedFontSize ::
     *   (Integer) 
     * :minimumFontSize ::
     *   (Integer) 
     * :minimumLogicalFontSize ::
     *   (Integer) 
     * :defaultEncoding ::
     *   (StringUtf16) Default encoding for Web content. If empty "ISO-8859-1" will be used. Also
     *   configurable using the "default-encoding" command-line switch.
     * :remoteFonts ::
     *   (Symbol from _enum_State_) Controls the loading of fonts from remote sources. Also configurable using
     *   the "disable-remote-fonts" command-line switch.
     * :javascript ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can be executed. Also configurable using the
     *   "disable-javascript" command-line switch.
     * :javascriptOpenWindows ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can be used for opening windows. Also
     *   configurable using the "disable-javascript-open-windows" command-line
     *   switch.
     * :javascriptCloseWindows ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can be used to close windows that were not
     *   opened via JavaScript. JavaScript can still be used to close windows that
     *   were opened via JavaScript or that have no back/forward history. Also
     *   configurable using the "disable-javascript-close-windows" command-line
     *   switch.
     * :javascriptAccessClipboard ::
     *   (Symbol from _enum_State_) Controls whether JavaScript can access the clipboard. Also configurable
     *   using the "disable-javascript-access-clipboard" command-line switch.
     * :javascriptDomPaste ::
     *   (Symbol from _enum_State_) Controls whether DOM pasting is supported in the editor via
     *   execCommand("paste"). The |javascript_access_clipboard| setting must also
     *   be enabled. Also configurable using the "disable-javascript-dom-paste"
     *   command-line switch.
     * :plugins ::
     *   (Symbol from _enum_State_) Controls whether any plugins will be loaded. Also configurable using the
     *   "disable-plugins" command-line switch.
     * :universalAccessFromFileUrls ::
     *   (Symbol from _enum_State_) Controls whether file URLs will have access to all URLs. Also configurable
     *   using the "allow-universal-access-from-files" command-line switch.
     * :fileAccessFromFileUrls ::
     *   (Symbol from _enum_State_) Controls whether file URLs will have access to other file URLs. Also
     *   configurable using the "allow-access-from-files" command-line switch.
     * :webSecurity ::
     *   (Symbol from _enum_State_) Controls whether web security restrictions (same-origin policy) will be
     *   enforced. Disabling this setting is not recommend as it will allow risky
     *   security behavior such as cross-site scripting (XSS). Also configurable
     *   using the "disable-web-security" command-line switch.
     * :imageLoading ::
     *   (Symbol from _enum_State_) Controls whether image URLs will be loaded from the network. A cached image
     *   will still be rendered if requested. Also configurable using the
     *   "disable-image-loading" command-line switch.
     * :imageShrinkStandaloneToFit ::
     *   (Symbol from _enum_State_) Controls whether standalone images will be shrunk to fit the page. Also
     *   configurable using the "image-shrink-standalone-to-fit" command-line
     *   switch.
     * :textAreaResize ::
     *   (Symbol from _enum_State_) Controls whether text areas can be resized. Also configurable using the
     *   "disable-text-area-resize" command-line switch.
     * :tabToLinks ::
     *   (Symbol from _enum_State_) Controls whether the tab key can advance focus to links. Also configurable
     *   using the "disable-tab-to-links" command-line switch.
     * :localStorage ::
     *   (Symbol from _enum_State_) Controls whether local storage can be used. Also configurable using the
     *   "disable-local-storage" command-line switch.
     * :databases ::
     *   (Symbol from _enum_State_) Controls whether databases can be used. Also configurable using the
     *   "disable-databases" command-line switch.
     * :applicationCache ::
     *   (Symbol from _enum_State_) Controls whether the application cache can be used. Also configurable using
     *   the "disable-application-cache" command-line switch.
     * :webgl ::
     *   (Symbol from _enum_State_) Controls whether WebGL can be used. Note that WebGL requires hardware
     *   support and may not work on all systems even when enabled. Also
     *   configurable using the "disable-webgl" command-line switch.
     * :backgroundColor ::
     *   (Integer) Opaque background color used for the browser before a document is loaded
     *   and when no document color is specified. By default the background color
     *   will be the same as CefSettings.background_color. Only the RGB compontents
     *   of the specified value will be used. The alpha component must greater than
     *   0 to enable use of the background color but will be otherwise ignored.
     * :acceptLanguageList ::
     *   (StringUtf16) Comma delimited ordered list of language codes without any whitespace that
     *   will be used in the "Accept-Language" HTTP header. May be set globally
     *   using the CefBrowserSettings.accept_language_list value. If both values are
     *   empty then "en-US,en" will be used.
     */
    public static final class BrowserSettings extends Struct {
        public UnsignedLong size = new UnsignedLong();
        public Signed32 windowlessFrameRate = new Signed32();
        public StringUtf16 standardFontFamily = inner(new StringUtf16(getRuntime()));
        public StringUtf16 fixedFontFamily = inner(new StringUtf16(getRuntime()));
        public StringUtf16 serifFontFamily = inner(new StringUtf16(getRuntime()));
        public StringUtf16 sansSerifFontFamily = inner(new StringUtf16(getRuntime()));
        public StringUtf16 cursiveFontFamily = inner(new StringUtf16(getRuntime()));
        public StringUtf16 fantasyFontFamily = inner(new StringUtf16(getRuntime()));
        public Signed32 defaultFontSize = new Signed32();
        public Signed32 defaultFixedFontSize = new Signed32();
        public Signed32 minimumFontSize = new Signed32();
        public Signed32 minimumLogicalFontSize = new Signed32();
        public StringUtf16 defaultEncoding = inner(new StringUtf16(getRuntime()));
        public Enum<State> remoteFonts = new Enum<>(State.class);
        public Enum<State> javascript = new Enum<>(State.class);
        public Enum<State> javascriptOpenWindows = new Enum<>(State.class);
        public Enum<State> javascriptCloseWindows = new Enum<>(State.class);
        public Enum<State> javascriptAccessClipboard = new Enum<>(State.class);
        public Enum<State> javascriptDomPaste = new Enum<>(State.class);
        public Enum<State> plugins = new Enum<>(State.class);
        public Enum<State> universalAccessFromFileUrls = new Enum<>(State.class);
        public Enum<State> fileAccessFromFileUrls = new Enum<>(State.class);
        public Enum<State> webSecurity = new Enum<>(State.class);
        public Enum<State> imageLoading = new Enum<>(State.class);
        public Enum<State> imageShrinkStandaloneToFit = new Enum<>(State.class);
        public Enum<State> textAreaResize = new Enum<>(State.class);
        public Enum<State> tabToLinks = new Enum<>(State.class);
        public Enum<State> localStorage = new Enum<>(State.class);
        public Enum<State> databases = new Enum<>(State.class);
        public Enum<State> applicationCache = new Enum<>(State.class);
        public Enum<State> webgl = new Enum<>(State.class);
        public Unsigned32 backgroundColor = new Unsigned32();
        public StringUtf16 acceptLanguageList = inner(new StringUtf16(getRuntime()));
        public BrowserSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ReturnValue).</em>
     * 
     * === Options:
     * RV_CANCEL ::
     *   Cancel immediately.
     * RV_CONTINUE ::
     *   Continue immediately.
     * RV_CONTINUE_ASYNC ::
     *   Continue asynchronously (usually via a callback).
     * 
     * @method _enum_ReturnValue_
     * @return [Symbol]
     * @scope class
     */
    public enum ReturnValue implements EnumMapper.IntegerEnum {
        RV_CANCEL(0),
        RV_CONTINUE(1),
        RV_CONTINUE_ASYNC(2)
        ;
        
        private int nativeInt;
        
        private ReturnValue(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :spec ::
     *   (StringUtf16) The complete URL specification.
     * :scheme ::
     *   (StringUtf16) Scheme component not including the colon (e.g., "http").
     * :username ::
     *   (StringUtf16) User name component.
     * :password ::
     *   (StringUtf16) Password component.
     * :host ::
     *   (StringUtf16) Host component. This may be a hostname, an IPv4 address or an IPv6 literal
     *   surrounded by square brackets (e.g., "(2001:db8::1)").
     * :port ::
     *   (StringUtf16) Port number component.
     * :origin ::
     *   (StringUtf16) Origin contains just the scheme, host, and port from a URL. Equivalent to
     *   clearing any username and password, replacing the path with a slash, and
     *   clearing everything after that. This value will be empty for non-standard
     *   URLs.
     * :path ::
     *   (StringUtf16) Path component including the first slash following the host.
     * :query ::
     *   (StringUtf16) Query string component (i.e., everything following the '?').
     */
    public static final class Urlparts extends Struct {
        public StringUtf16 spec = inner(new StringUtf16(getRuntime()));
        public StringUtf16 scheme = inner(new StringUtf16(getRuntime()));
        public StringUtf16 username = inner(new StringUtf16(getRuntime()));
        public StringUtf16 password = inner(new StringUtf16(getRuntime()));
        public StringUtf16 host = inner(new StringUtf16(getRuntime()));
        public StringUtf16 port = inner(new StringUtf16(getRuntime()));
        public StringUtf16 origin = inner(new StringUtf16(getRuntime()));
        public StringUtf16 path = inner(new StringUtf16(getRuntime()));
        public StringUtf16 query = inner(new StringUtf16(getRuntime()));
        public Urlparts(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :name ::
     *   (StringUtf16) The cookie name.
     * :value ::
     *   (StringUtf16) The cookie value.
     * :domain ::
     *   (StringUtf16) If |domain| is empty a host cookie will be created instead of a domain
     *   cookie. Domain cookies are stored with a leading "." and are visible to
     *   sub-domains whereas host cookies are not.
     * :path ::
     *   (StringUtf16) If |path| is non-empty only URLs at or below the path will get the cookie
     *   value.
     * :secure ::
     *   (Integer) If |secure| is true the cookie will only be sent for HTTPS requests.
     * :httponly ::
     *   (Integer) If |httponly| is true the cookie will only be sent for HTTP requests.
     * :creation ::
     *   (unknown) The cookie creation date. This is automatically populated by the system on
     *   cookie creation.
     * :lastAccess ::
     *   (unknown) The cookie last access date. This is automatically populated by the system
     *   on access.
     * :hasExpires ::
     *   (Integer) The cookie expiration date is only valid if |has_expires| is true.
     * :expires ::
     *   (unknown) 
     */
    public static final class Cookie extends Struct {
        public StringUtf16 name = inner(new StringUtf16(getRuntime()));
        public StringUtf16 value = inner(new StringUtf16(getRuntime()));
        public StringUtf16 domain = inner(new StringUtf16(getRuntime()));
        public StringUtf16 path = inner(new StringUtf16(getRuntime()));
        public Signed32 secure = new Signed32();
        public Signed32 httponly = new Signed32();
        public Pointer creation = new Pointer();
        public Pointer lastAccess = new Pointer();
        public Signed32 hasExpires = new Signed32();
        public Pointer expires = new Pointer();
        public Cookie(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:TerminationStatus).</em>
     * 
     * === Options:
     * TS_ABNORMAL_TERMINATION ::
     *   Non-zero exit status.
     * TS_PROCESS_WAS_KILLED ::
     *   SIGKILL or task manager kill.
     * TS_PROCESS_CRASHED ::
     *   Segmentation fault.
     * 
     * @method _enum_TerminationStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum TerminationStatus implements EnumMapper.IntegerEnum {
        TS_ABNORMAL_TERMINATION(0),
        TS_PROCESS_WAS_KILLED(1),
        TS_PROCESS_CRASHED(2)
        ;
        
        private int nativeInt;
        
        private TerminationStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PathKey).</em>
     * 
     * === Options:
     * PK_DIR_CURRENT ::
     *   Current directory.
     * PK_DIR_EXE ::
     *   Directory containing PK_FILE_EXE.
     * PK_DIR_MODULE ::
     *   Directory containing PK_FILE_MODULE.
     * PK_DIR_TEMP ::
     *   Temporary directory.
     * PK_FILE_EXE ::
     *   Path and filename of the current executable.
     * PK_FILE_MODULE ::
     *   Path and filename of the module containing the CEF code (usually the libcef
     *   module).
     * PK_LOCAL_APP_DATA ::
     *   "Local Settings\Application Data" directory under the user profile
     *   directory on Windows.
     * PK_USER_DATA ::
     *   "Application Data" directory under the user profile directory on Windows
     *   and "~/Library/Application Support" directory on Mac OS X.
     * 
     * @method _enum_PathKey_
     * @return [Symbol]
     * @scope class
     */
    public enum PathKey implements EnumMapper.IntegerEnum {
        PK_DIR_CURRENT(0),
        PK_DIR_EXE(1),
        PK_DIR_MODULE(2),
        PK_DIR_TEMP(3),
        PK_FILE_EXE(4),
        PK_FILE_MODULE(5),
        PK_LOCAL_APP_DATA(6),
        PK_USER_DATA(7)
        ;
        
        private int nativeInt;
        
        private PathKey(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:StorageType).</em>
     * 
     * === Options:
     * ST_LOCALSTORAGE ::
     *   
     * ST_SESSIONSTORAGE ::
     *   
     * 
     * @method _enum_StorageType_
     * @return [Symbol]
     * @scope class
     */
    public enum StorageType implements EnumMapper.IntegerEnum {
        ST_LOCALSTORAGE(0),
        ST_SESSIONSTORAGE(1)
        ;
        
        private int nativeInt;
        
        private StorageType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:Errorcode).</em>
     * 
     * === Options:
     * ERR_NONE ::
     *   
     * ERR_FAILED ::
     *   
     * ERR_ABORTED ::
     *   
     * ERR_INVALID_ARGUMENT ::
     *   
     * ERR_INVALID_HANDLE ::
     *   
     * ERR_FILE_NOT_FOUND ::
     *   
     * ERR_TIMED_OUT ::
     *   
     * ERR_FILE_TOO_BIG ::
     *   
     * ERR_UNEXPECTED ::
     *   
     * ERR_ACCESS_DENIED ::
     *   
     * ERR_NOT_IMPLEMENTED ::
     *   
     * ERR_CONNECTION_CLOSED ::
     *   
     * ERR_CONNECTION_RESET ::
     *   
     * ERR_CONNECTION_REFUSED ::
     *   
     * ERR_CONNECTION_ABORTED ::
     *   
     * ERR_CONNECTION_FAILED ::
     *   
     * ERR_NAME_NOT_RESOLVED ::
     *   
     * ERR_INTERNET_DISCONNECTED ::
     *   
     * ERR_SSL_PROTOCOL_ERROR ::
     *   
     * ERR_ADDRESS_INVALID ::
     *   
     * ERR_ADDRESS_UNREACHABLE ::
     *   
     * ERR_SSL_CLIENT_AUTH_CERT_NEEDED ::
     *   
     * ERR_TUNNEL_CONNECTION_FAILED ::
     *   
     * ERR_NO_SSL_VERSIONS_ENABLED ::
     *   
     * ERR_SSL_VERSION_OR_CIPHER_MISMATCH ::
     *   
     * ERR_SSL_RENEGOTIATION_REQUESTED ::
     *   
     * ERR_CERT_COMMON_NAME_INVALID ::
     *   
     * ERR_CERT_DATE_INVALID ::
     *   
     * ERR_CERT_AUTHORITY_INVALID ::
     *   
     * ERR_CERT_CONTAINS_ERRORS ::
     *   
     * ERR_CERT_NO_REVOCATION_MECHANISM ::
     *   
     * ERR_CERT_UNABLE_TO_CHECK_REVOCATION ::
     *   
     * ERR_CERT_REVOKED ::
     *   
     * ERR_CERT_INVALID ::
     *   
     * ERR_CERT_WEAK_SIGNATURE_ALGORITHM ::
     *   
     * ERR_CERT_NON_UNIQUE_NAME ::
     *   -209 is available: was ERR_CERT_NOT_IN_DNS.
     * ERR_CERT_WEAK_KEY ::
     *   
     * ERR_CERT_NAME_CONSTRAINT_VIOLATION ::
     *   
     * ERR_CERT_VALIDITY_TOO_LONG ::
     *   
     * ERR_INVALID_URL ::
     *   
     * ERR_DISALLOWED_URL_SCHEME ::
     *   
     * ERR_UNKNOWN_URL_SCHEME ::
     *   
     * ERR_TOO_MANY_REDIRECTS ::
     *   
     * ERR_UNSAFE_REDIRECT ::
     *   
     * ERR_UNSAFE_PORT ::
     *   
     * ERR_INVALID_RESPONSE ::
     *   
     * ERR_INVALID_CHUNKED_ENCODING ::
     *   
     * ERR_METHOD_NOT_SUPPORTED ::
     *   
     * ERR_UNEXPECTED_PROXY_AUTH ::
     *   
     * ERR_EMPTY_RESPONSE ::
     *   
     * ERR_RESPONSE_HEADERS_TOO_BIG ::
     *   
     * ERR_CACHE_MISS ::
     *   
     * ERR_INSECURE_RESPONSE ::
     *   
     * 
     * @method _enum_Errorcode_
     * @return [Symbol]
     * @scope class
     */
    public enum Errorcode implements EnumMapper.IntegerEnum {
        ERR_NONE(0),
        ERR_FAILED(-2),
        ERR_ABORTED(-3),
        ERR_INVALID_ARGUMENT(-4),
        ERR_INVALID_HANDLE(-5),
        ERR_FILE_NOT_FOUND(-6),
        ERR_TIMED_OUT(-7),
        ERR_FILE_TOO_BIG(-8),
        ERR_UNEXPECTED(-9),
        ERR_ACCESS_DENIED(-10),
        ERR_NOT_IMPLEMENTED(-11),
        ERR_CONNECTION_CLOSED(-100),
        ERR_CONNECTION_RESET(-101),
        ERR_CONNECTION_REFUSED(-102),
        ERR_CONNECTION_ABORTED(-103),
        ERR_CONNECTION_FAILED(-104),
        ERR_NAME_NOT_RESOLVED(-105),
        ERR_INTERNET_DISCONNECTED(-106),
        ERR_SSL_PROTOCOL_ERROR(-107),
        ERR_ADDRESS_INVALID(-108),
        ERR_ADDRESS_UNREACHABLE(-109),
        ERR_SSL_CLIENT_AUTH_CERT_NEEDED(-110),
        ERR_TUNNEL_CONNECTION_FAILED(-111),
        ERR_NO_SSL_VERSIONS_ENABLED(-112),
        ERR_SSL_VERSION_OR_CIPHER_MISMATCH(-113),
        ERR_SSL_RENEGOTIATION_REQUESTED(-114),
        ERR_CERT_COMMON_NAME_INVALID(-200),
        ERR_CERT_DATE_INVALID(-201),
        ERR_CERT_AUTHORITY_INVALID(-202),
        ERR_CERT_CONTAINS_ERRORS(-203),
        ERR_CERT_NO_REVOCATION_MECHANISM(-204),
        ERR_CERT_UNABLE_TO_CHECK_REVOCATION(-205),
        ERR_CERT_REVOKED(-206),
        ERR_CERT_INVALID(-207),
        ERR_CERT_WEAK_SIGNATURE_ALGORITHM(-208),
        ERR_CERT_NON_UNIQUE_NAME(-210),
        ERR_CERT_WEAK_KEY(-211),
        ERR_CERT_NAME_CONSTRAINT_VIOLATION(-212),
        ERR_CERT_VALIDITY_TOO_LONG(-213),
        ERR_INVALID_URL(-300),
        ERR_DISALLOWED_URL_SCHEME(-301),
        ERR_UNKNOWN_URL_SCHEME(-302),
        ERR_TOO_MANY_REDIRECTS(-310),
        ERR_UNSAFE_REDIRECT(-311),
        ERR_UNSAFE_PORT(-312),
        ERR_INVALID_RESPONSE(-320),
        ERR_INVALID_CHUNKED_ENCODING(-321),
        ERR_METHOD_NOT_SUPPORTED(-322),
        ERR_UNEXPECTED_PROXY_AUTH(-323),
        ERR_EMPTY_RESPONSE(-324),
        ERR_RESPONSE_HEADERS_TOO_BIG(-325),
        ERR_CACHE_MISS(-400),
        ERR_INSECURE_RESPONSE(-501)
        ;
        
        private int nativeInt;
        
        private Errorcode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:CertStatus).</em>
     * 
     * === Options:
     * NONE ::
     *   
     * COMMON_NAME_INVALID ::
     *   
     * DATE_INVALID ::
     *   
     * AUTHORITY_INVALID ::
     *   
     * NO_REVOCATION_MECHANISM ::
     *   1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP).
     * UNABLE_TO_CHECK_REVOCATION ::
     *   
     * REVOKED ::
     *   
     * INVALID ::
     *   
     * WEAK_SIGNATURE_ALGORITHM ::
     *   
     * NON_UNIQUE_NAME ::
     *   1 << 9 was used for CERT_STATUS_NOT_IN_DNS
     * WEAK_KEY ::
     *   
     * PINNED_KEY_MISSING ::
     *   1 << 12 was used for CERT_STATUS_WEAK_DH_KEY
     * NAME_CONSTRAINT_VIOLATION ::
     *   
     * VALIDITY_TOO_LONG ::
     *   
     * IS_EV ::
     *   Bits 16 to 31 are for non-error statuses.
     * REV_CHECKING_ENABLED ::
     *   
     * SHA1_SIGNATURE_PRESENT ::
     *   Bit 18 was CERT_STATUS_IS_DNSSEC
     * CT_COMPLIANCE_FAILED ::
     *   
     * 
     * @method _enum_CertStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum CertStatus implements EnumMapper.IntegerEnum {
        NONE(0),
        COMMON_NAME_INVALID(1),
        DATE_INVALID(2),
        AUTHORITY_INVALID(4),
        NO_REVOCATION_MECHANISM(16),
        UNABLE_TO_CHECK_REVOCATION(32),
        REVOKED(64),
        INVALID(128),
        WEAK_SIGNATURE_ALGORITHM(256),
        NON_UNIQUE_NAME(1024),
        WEAK_KEY(2048),
        PINNED_KEY_MISSING(8192),
        NAME_CONSTRAINT_VIOLATION(16384),
        VALIDITY_TOO_LONG(32768),
        IS_EV(65536),
        REV_CHECKING_ENABLED(131072),
        SHA1_SIGNATURE_PRESENT(524288),
        CT_COMPLIANCE_FAILED(1048576)
        ;
        
        private int nativeInt;
        
        private CertStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:WindowOpenDisposition).</em>
     * 
     * === Options:
     * WOD_UNKNOWN ::
     *   
     * WOD_CURRENT_TAB ::
     *   
     * WOD_SINGLETON_TAB ::
     *   
     * WOD_NEW_FOREGROUND_TAB ::
     *   
     * WOD_NEW_BACKGROUND_TAB ::
     *   
     * WOD_NEW_POPUP ::
     *   
     * WOD_NEW_WINDOW ::
     *   
     * WOD_SAVE_TO_DISK ::
     *   
     * WOD_OFF_THE_RECORD ::
     *   
     * WOD_IGNORE_ACTION ::
     *   
     * 
     * @method _enum_WindowOpenDisposition_
     * @return [Symbol]
     * @scope class
     */
    public enum WindowOpenDisposition implements EnumMapper.IntegerEnum {
        WOD_UNKNOWN(0),
        WOD_CURRENT_TAB(1),
        WOD_SINGLETON_TAB(2),
        WOD_NEW_FOREGROUND_TAB(3),
        WOD_NEW_BACKGROUND_TAB(4),
        WOD_NEW_POPUP(5),
        WOD_NEW_WINDOW(6),
        WOD_SAVE_TO_DISK(7),
        WOD_OFF_THE_RECORD(8),
        WOD_IGNORE_ACTION(9)
        ;
        
        private int nativeInt;
        
        private WindowOpenDisposition(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DragOperationsMask).</em>
     * 
     * === Options:
     * OPERATION_NONE ::
     *   
     * OPERATION_COPY ::
     *   
     * OPERATION_LINK ::
     *   
     * OPERATION_GENERIC ::
     *   
     * OPERATION_PRIVATE ::
     *   
     * OPERATION_MOVE ::
     *   
     * OPERATION_DELETE ::
     *   
     * OPERATION_EVERY ::
     *   
     * 
     * @method _enum_DragOperationsMask_
     * @return [Symbol]
     * @scope class
     */
    public enum DragOperationsMask implements EnumMapper.IntegerEnum {
        OPERATION_NONE(0),
        OPERATION_COPY(1),
        OPERATION_LINK(2),
        OPERATION_GENERIC(4),
        OPERATION_PRIVATE(8),
        OPERATION_MOVE(16),
        OPERATION_DELETE(32),
        OPERATION_EVERY(33)
        ;
        
        private int nativeInt;
        
        private DragOperationsMask(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:V8Accesscontrol).</em>
     * 
     * === Options:
     * ACCESS_CONTROL_DEFAULT ::
     *   
     * ACCESS_CONTROL_ALL_CAN_READ ::
     *   
     * ACCESS_CONTROL_ALL_CAN_WRITE ::
     *   
     * ACCESS_CONTROL_PROHIBITS_OVERWRITING ::
     *   
     * 
     * @method _enum_V8Accesscontrol_
     * @return [Symbol]
     * @scope class
     */
    public enum V8Accesscontrol implements EnumMapper.IntegerEnum {
        ACCESS_CONTROL_DEFAULT(0),
        ACCESS_CONTROL_ALL_CAN_READ(1),
        ACCESS_CONTROL_ALL_CAN_WRITE(2),
        ACCESS_CONTROL_PROHIBITS_OVERWRITING(4)
        ;
        
        private int nativeInt;
        
        private V8Accesscontrol(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:V8Propertyattribute).</em>
     * 
     * === Options:
     * PROPERTY_ATTRIBUTE_NONE ::
     *   
     * PROPERTY_ATTRIBUTE_READONLY ::
     *   Configurable
     * PROPERTY_ATTRIBUTE_DONTENUM ::
     *   Not writeable
     * PROPERTY_ATTRIBUTE_DONTDELETE ::
     *   Not enumerable
     * 
     * @method _enum_V8Propertyattribute_
     * @return [Symbol]
     * @scope class
     */
    public enum V8Propertyattribute implements EnumMapper.IntegerEnum {
        PROPERTY_ATTRIBUTE_NONE(0),
        PROPERTY_ATTRIBUTE_READONLY(1),
        PROPERTY_ATTRIBUTE_DONTENUM(2),
        PROPERTY_ATTRIBUTE_DONTDELETE(4)
        ;
        
        private int nativeInt;
        
        private V8Propertyattribute(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PostdataelementType).</em>
     * 
     * === Options:
     * PDE_TYPE_EMPTY ::
     *   
     * PDE_TYPE_BYTES ::
     *   
     * PDE_TYPE_FILE ::
     *   
     * 
     * @method _enum_PostdataelementType_
     * @return [Symbol]
     * @scope class
     */
    public enum PostdataelementType implements EnumMapper.IntegerEnum {
        PDE_TYPE_EMPTY(0),
        PDE_TYPE_BYTES(1),
        PDE_TYPE_FILE(2)
        ;
        
        private int nativeInt;
        
        private PostdataelementType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ResourceType).</em>
     * 
     * === Options:
     * RT_MAIN_FRAME ::
     *   Top level page.
     * RT_SUB_FRAME ::
     *   Frame or iframe.
     * RT_STYLESHEET ::
     *   CSS stylesheet.
     * RT_SCRIPT ::
     *   External script.
     * RT_IMAGE ::
     *   Image (jpg/gif/png/etc).
     * RT_FONT_RESOURCE ::
     *   Font.
     * RT_SUB_RESOURCE ::
     *   Some other subresource. This is the default type if the actual type is
     *   unknown.
     * RT_OBJECT ::
     *   Object (or embed) tag for a plugin, or a resource that a plugin requested.
     * RT_MEDIA ::
     *   Media resource.
     * RT_WORKER ::
     *   Main resource of a dedicated worker.
     * RT_SHARED_WORKER ::
     *   Main resource of a shared worker.
     * RT_PREFETCH ::
     *   Explicitly requested prefetch.
     * RT_FAVICON ::
     *   Favicon.
     * RT_XHR ::
     *   XMLHttpRequest.
     * RT_PING ::
     *   A request for a <ping>
     * RT_SERVICE_WORKER ::
     *   Main resource of a service worker.
     * RT_CSP_REPORT ::
     *   A report of Content Security Policy violations.
     * RT_PLUGIN_RESOURCE ::
     *   A resource that a plugin requested.
     * 
     * @method _enum_ResourceType_
     * @return [Symbol]
     * @scope class
     */
    public enum ResourceType implements EnumMapper.IntegerEnum {
        RT_MAIN_FRAME(0),
        RT_SUB_FRAME(1),
        RT_STYLESHEET(2),
        RT_SCRIPT(3),
        RT_IMAGE(4),
        RT_FONT_RESOURCE(5),
        RT_SUB_RESOURCE(6),
        RT_OBJECT(7),
        RT_MEDIA(8),
        RT_WORKER(9),
        RT_SHARED_WORKER(10),
        RT_PREFETCH(11),
        RT_FAVICON(12),
        RT_XHR(13),
        RT_PING(14),
        RT_SERVICE_WORKER(15),
        RT_CSP_REPORT(16),
        RT_PLUGIN_RESOURCE(17)
        ;
        
        private int nativeInt;
        
        private ResourceType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:TransitionType).</em>
     * 
     * === Options:
     * TT_LINK ::
     *   Source is a link click or the JavaScript window.open function. This is
     *   also the default value for requests like sub-resource loads that are not
     *   navigations.
     * TT_EXPLICIT ::
     *   Source is some other "explicit" navigation action such as creating a new
     *   browser or using the LoadURL function. This is also the default value
     *   for navigations where the actual type is unknown.
     * TT_AUTO_SUBFRAME ::
     *   Source is a subframe navigation. This is any content that is automatically
     *   loaded in a non-toplevel frame. For example, if a page consists of several
     *   frames containing ads, those ad URLs will have this transition type.
     *   The user may not even realize the content in these pages is a separate
     *   frame, so may not care about the URL.
     * TT_MANUAL_SUBFRAME ::
     *   Source is a subframe navigation explicitly requested by the user that will
     *   generate new navigation entries in the back/forward list. These are
     *   probably more important than frames that were automatically loaded in
     *   the background because the user probably cares about the fact that this
     *   link was loaded.
     * TT_FORM_SUBMIT ::
     *   Source is a form submission by the user. NOTE: In some situations
     *   submitting a form does not result in this transition type. This can happen
     *   if the form uses a script to submit the contents.
     * TT_RELOAD ::
     *   Source is a "reload" of the page via the Reload function or by re-visiting
     *   the same URL. NOTE: This is distinct from the concept of whether a
     *   particular load uses "reload semantics" (i.e. bypasses cached data).
     * TT_SOURCE_MASK ::
     *   General mask defining the bits used for the source values.
     * TT_BLOCKED_FLAG ::
     *   Attempted to visit a URL but was blocked.
     * TT_FORWARD_BACK_FLAG ::
     *   Used the Forward or Back function to navigate among browsing history.
     * TT_CHAIN_START_FLAG ::
     *   The beginning of a navigation chain.
     * TT_CHAIN_END_FLAG ::
     *   The last transition in a redirect chain.
     * TT_CLIENT_REDIRECT_FLAG ::
     *   Redirects caused by JavaScript or a meta refresh tag on the page.
     * TT_SERVER_REDIRECT_FLAG ::
     *   Redirects sent from the server by HTTP headers.
     * TT_IS_REDIRECT_MASK ::
     *   Used to test whether a transition involves a redirect.
     * TT_QUALIFIER_MASK ::
     *   General mask defining the bits used for the qualifiers.
     * 
     * @method _enum_TransitionType_
     * @return [Symbol]
     * @scope class
     */
    public enum TransitionType implements EnumMapper.IntegerEnum {
        TT_LINK(0),
        TT_EXPLICIT(1),
        TT_AUTO_SUBFRAME(3),
        TT_MANUAL_SUBFRAME(4),
        TT_FORM_SUBMIT(7),
        TT_RELOAD(8),
        TT_SOURCE_MASK(255),
        TT_BLOCKED_FLAG(8388608),
        TT_FORWARD_BACK_FLAG(16777216),
        TT_CHAIN_START_FLAG(268435456),
        TT_CHAIN_END_FLAG(536870912),
        TT_CLIENT_REDIRECT_FLAG(1073741824),
//        TT_SERVER_REDIRECT_FLAG(2147483648),
//        TT_IS_REDIRECT_MASK(3221225472),
//        TT_QUALIFIER_MASK(4294967040)
        ;
        
        private int nativeInt;
        
        private TransitionType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:UrlrequestFlags).</em>
     * 
     * === Options:
     * UR_FLAG_NONE ::
     *   Default behavior.
     * UR_FLAG_SKIP_CACHE ::
     *   If set the cache will be skipped when handling the request.
     * UR_FLAG_ALLOW_CACHED_CREDENTIALS ::
     *   If set user name, password, and cookies may be sent with the request, and
     *   cookies may be saved from the response.
     * UR_FLAG_REPORT_UPLOAD_PROGRESS ::
     *   If set upload progress events will be generated when a request has a body.
     * UR_FLAG_NO_DOWNLOAD_DATA ::
     *   If set the CefURLRequestClient::OnDownloadData method will not be called.
     * UR_FLAG_NO_RETRY_ON_5XX ::
     *   If set 5XX redirect errors will be propagated to the observer instead of
     *   automatically re-tried. This currently only applies for requests
     *   originated in the browser process.
     * 
     * @method _enum_UrlrequestFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum UrlrequestFlags implements EnumMapper.IntegerEnum {
        UR_FLAG_NONE(0),
        UR_FLAG_SKIP_CACHE(1),
        UR_FLAG_ALLOW_CACHED_CREDENTIALS(2),
        UR_FLAG_REPORT_UPLOAD_PROGRESS(8),
        UR_FLAG_NO_DOWNLOAD_DATA(64),
        UR_FLAG_NO_RETRY_ON_5XX(128)
        ;
        
        private int nativeInt;
        
        private UrlrequestFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:UrlrequestStatus).</em>
     * 
     * === Options:
     * UR_UNKNOWN ::
     *   Unknown status.
     * UR_SUCCESS ::
     *   Request succeeded.
     * UR_IO_PENDING ::
     *   An IO request is pending, and the caller will be informed when it is
     *   completed.
     * UR_CANCELED ::
     *   Request was canceled programatically.
     * UR_FAILED ::
     *   Request failed for some reason.
     * 
     * @method _enum_UrlrequestStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum UrlrequestStatus implements EnumMapper.IntegerEnum {
        UR_UNKNOWN(0),
        UR_SUCCESS(1),
        UR_IO_PENDING(2),
        UR_CANCELED(3),
        UR_FAILED(4)
        ;
        
        private int nativeInt;
        
        private UrlrequestStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     */
    public static final class Point extends Struct {
        public Signed32 x = new Signed32();
        public Signed32 y = new Signed32();
        public Point(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     * :width ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     */
    public static final class Rect extends Struct {
        public Signed32 x = new Signed32();
        public Signed32 y = new Signed32();
        public Signed32 width = new Signed32();
        public Signed32 height = new Signed32();
        public Rect(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :width ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     */
    public static final class Size extends Struct {
        public Signed32 width = new Signed32();
        public Signed32 height = new Signed32();
        public Size(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :from ::
     *   (Integer) 
     * :to ::
     *   (Integer) 
     */
    public static final class Range extends Struct {
        public Signed32 from = new Signed32();
        public Signed32 to = new Signed32();
        public Range(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :top ::
     *   (Integer) 
     * :left ::
     *   (Integer) 
     * :bottom ::
     *   (Integer) 
     * :right ::
     *   (Integer) 
     */
    public static final class Insets extends Struct {
        public Signed32 top = new Signed32();
        public Signed32 left = new Signed32();
        public Signed32 bottom = new Signed32();
        public Signed32 right = new Signed32();
        public Insets(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :bounds ::
     *   (Rect) Bounds of the region.
     * :draggable ::
     *   (Integer) True (1) this this region is draggable and false (0) otherwise.
     */
    public static final class DraggableRegion extends Struct {
        public Rect bounds = inner(new Rect(getRuntime()));
        public Signed32 draggable = new Signed32();
        public DraggableRegion(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ProcessId).</em>
     * 
     * === Options:
     * PID_BROWSER ::
     *   Browser process.
     * PID_RENDERER ::
     *   Renderer process.
     * 
     * @method _enum_ProcessId_
     * @return [Symbol]
     * @scope class
     */
    public enum ProcessId implements EnumMapper.IntegerEnum {
        PID_BROWSER(0),
        PID_RENDERER(1)
        ;
        
        private int nativeInt;
        
        private ProcessId(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ThreadId).</em>
     * 
     * === Options:
     * TID_UI ::
     *   The main thread in the browser. This will be the same as the main
     *   application thread if CefInitialize() is called with a
     *   CefSettings.multi_threaded_message_loop value of false.
     * TID_DB ::
     *   Used to interact with the database.
     * TID_FILE ::
     *   Used to interact with the file system.
     * TID_FILE_USER_BLOCKING ::
     *   Used for file system operations that block user interactions.
     *   Responsiveness of this thread affects users.
     * TID_PROCESS_LAUNCHER ::
     *   Used to launch and terminate browser processes.
     * TID_CACHE ::
     *   Used to handle slow HTTP cache operations.
     * TID_IO ::
     *   Used to process IPC and network messages.
     * TID_RENDERER ::
     *   The main thread in the renderer. Used for all WebKit and V8 interaction.
     * 
     * @method _enum_ThreadId_
     * @return [Symbol]
     * @scope class
     */
    public enum ThreadId implements EnumMapper.IntegerEnum {
        TID_UI(0),
        TID_DB(1),
        TID_FILE(2),
        TID_FILE_USER_BLOCKING(3),
        TID_PROCESS_LAUNCHER(4),
        TID_CACHE(5),
        TID_IO(6),
        TID_RENDERER(7)
        ;
        
        private int nativeInt;
        
        private ThreadId(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ThreadPriority).</em>
     * 
     * === Options:
     * TP_BACKGROUND ::
     *   Suitable for threads that shouldn't disrupt high priority work.
     * TP_NORMAL ::
     *   Default priority level.
     * TP_DISPLAY ::
     *   Suitable for threads which generate data for the display (at ~60Hz).
     * TP_REALTIME_AUDIO ::
     *   Suitable for low-latency, glitch-resistant audio.
     * 
     * @method _enum_ThreadPriority_
     * @return [Symbol]
     * @scope class
     */
    public enum ThreadPriority implements EnumMapper.IntegerEnum {
        TP_BACKGROUND(0),
        TP_NORMAL(1),
        TP_DISPLAY(2),
        TP_REALTIME_AUDIO(3)
        ;
        
        private int nativeInt;
        
        private ThreadPriority(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MessageLoopType).</em>
     * 
     * === Options:
     * ML_TYPE_DEFAULT ::
     *   Supports tasks and timers.
     * ML_TYPE_UI ::
     *   Supports tasks, timers and native UI events (e.g. Windows messages).
     * ML_TYPE_IO ::
     *   Supports tasks, timers and asynchronous IO events.
     * 
     * @method _enum_MessageLoopType_
     * @return [Symbol]
     * @scope class
     */
    public enum MessageLoopType implements EnumMapper.IntegerEnum {
        ML_TYPE_DEFAULT(0),
        ML_TYPE_UI(1),
        ML_TYPE_IO(2)
        ;
        
        private int nativeInt;
        
        private MessageLoopType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ComInitMode).</em>
     * 
     * === Options:
     * NONE ::
     *   No COM initialization.
     * STA ::
     *   Initialize COM using single-threaded apartments.
     * MTA ::
     *   Initialize COM using multi-threaded apartments.
     * 
     * @method _enum_ComInitMode_
     * @return [Symbol]
     * @scope class
     */
    public enum ComInitMode implements EnumMapper.IntegerEnum {
        NONE(0),
        STA(1),
        MTA(2)
        ;
        
        private int nativeInt;
        
        private ComInitMode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ValueType).</em>
     * 
     * === Options:
     * VTYPE_INVALID ::
     *   
     * VTYPE_NULL ::
     *   
     * VTYPE_BOOL ::
     *   
     * VTYPE_INT ::
     *   
     * VTYPE_DOUBLE ::
     *   
     * VTYPE_STRING ::
     *   
     * VTYPE_BINARY ::
     *   
     * VTYPE_DICTIONARY ::
     *   
     * VTYPE_LIST ::
     *   
     * 
     * @method _enum_ValueType_
     * @return [Symbol]
     * @scope class
     */
    public enum ValueType implements EnumMapper.IntegerEnum {
        VTYPE_INVALID(0),
        VTYPE_NULL(1),
        VTYPE_BOOL(2),
        VTYPE_INT(3),
        VTYPE_DOUBLE(4),
        VTYPE_STRING(5),
        VTYPE_BINARY(6),
        VTYPE_DICTIONARY(7),
        VTYPE_LIST(8)
        ;
        
        private int nativeInt;
        
        private ValueType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsdialogType).</em>
     * 
     * === Options:
     * JSDIALOGTYPE_ALERT ::
     *   
     * JSDIALOGTYPE_CONFIRM ::
     *   
     * JSDIALOGTYPE_PROMPT ::
     *   
     * 
     * @method _enum_JsdialogType_
     * @return [Symbol]
     * @scope class
     */
    public enum JsdialogType implements EnumMapper.IntegerEnum {
        JSDIALOGTYPE_ALERT(0),
        JSDIALOGTYPE_CONFIRM(1),
        JSDIALOGTYPE_PROMPT(2)
        ;
        
        private int nativeInt;
        
        private JsdialogType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :deviceScaleFactor ::
     *   (Float) Device scale factor. Specifies the ratio between physical and logical
     *   pixels.
     * :depth ::
     *   (Integer) The screen depth in bits per pixel.
     * :depthPerComponent ::
     *   (Integer) The bits per color component. This assumes that the colors are balanced
     *   equally.
     * :isMonochrome ::
     *   (Integer) This can be true for black and white printers.
     * :rect ::
     *   (Rect) This is set from the rcMonitor member of MONITORINFOEX, to whit:
     *     "A RECT structure that specifies the display monitor rectangle,
     *     expressed in virtual-screen coordinates. Note that if the monitor
     *     is not the primary display monitor, some of the rectangle's
     *     coordinates may be negative values."
     *   
     *   The |rect| and |available_rect| properties are used to determine the
     *   available surface for rendering popup views.
     * :availableRect ::
     *   (Rect) This is set from the rcWork member of MONITORINFOEX, to whit:
     *     "A RECT structure that specifies the work area rectangle of the
     *     display monitor that can be used by applications, expressed in
     *     virtual-screen coordinates. Windows uses this rectangle to
     *     maximize an application on the monitor. The rest of the area in
     *     rcMonitor contains system windows such as the task bar and side
     *     bars. Note that if the monitor is not the primary display monitor,
     *     some of the rectangle's coordinates may be negative values".
     *   
     *   The |rect| and |available_rect| properties are used to determine the
     *   available surface for rendering popup views.
     */
    public static final class ScreenInfo extends Struct {
        public Float deviceScaleFactor = new Float();
        public Signed32 depth = new Signed32();
        public Signed32 depthPerComponent = new Signed32();
        public Signed32 isMonochrome = new Signed32();
        public Rect rect = inner(new Rect(getRuntime()));
        public Rect availableRect = inner(new Rect(getRuntime()));
        public ScreenInfo(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MenuId).</em>
     * 
     * === Options:
     * BACK ::
     *   Navigation.
     * FORWARD ::
     *   
     * RELOAD ::
     *   
     * RELOAD_NOCACHE ::
     *   
     * STOPLOAD ::
     *   
     * UNDO ::
     *   Editing.
     * REDO ::
     *   
     * CUT ::
     *   
     * COPY ::
     *   
     * PASTE ::
     *   
     * DELETE ::
     *   
     * SELECT_ALL ::
     *   
     * FIND ::
     *   Miscellaneous.
     * PRINT ::
     *   
     * VIEW_SOURCE ::
     *   
     * SPELLCHECK_SUGGESTION_0 ::
     *   Spell checking word correction suggestions.
     * SPELLCHECK_SUGGESTION_1 ::
     *   
     * SPELLCHECK_SUGGESTION_2 ::
     *   
     * SPELLCHECK_SUGGESTION_3 ::
     *   
     * SPELLCHECK_SUGGESTION_4 ::
     *   
     * SPELLCHECK_SUGGESTION_LAST ::
     *   
     * NO_SPELLING_SUGGESTIONS ::
     *   
     * ADD_TO_DICTIONARY ::
     *   
     * CUSTOM_FIRST ::
     *   plugin placeholder menu items or Flash menu items.
     * CUSTOM_LAST ::
     *   
     * USER_FIRST ::
     *   defined in the tools/gritsettings/resource_ids file.
     * USER_LAST ::
     *   
     * 
     * @method _enum_MenuId_
     * @return [Symbol]
     * @scope class
     */
    public enum MenuId implements EnumMapper.IntegerEnum {
        BACK(100),
        FORWARD(101),
        RELOAD(102),
        RELOAD_NOCACHE(103),
        STOPLOAD(104),
        UNDO(110),
        REDO(111),
        CUT(112),
        COPY(113),
        PASTE(114),
        DELETE(115),
        SELECT_ALL(116),
        FIND(130),
        PRINT(131),
        VIEW_SOURCE(132),
        SPELLCHECK_SUGGESTION_0(200),
        SPELLCHECK_SUGGESTION_1(201),
        SPELLCHECK_SUGGESTION_2(202),
        SPELLCHECK_SUGGESTION_3(203),
        SPELLCHECK_SUGGESTION_4(204),
        SPELLCHECK_SUGGESTION_LAST(204),
        NO_SPELLING_SUGGESTIONS(205),
        ADD_TO_DICTIONARY(206),
        CUSTOM_FIRST(220),
        CUSTOM_LAST(250),
        USER_FIRST(26500),
        USER_LAST(28500)
        ;
        
        private int nativeInt;
        
        private MenuId(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MouseButtonType).</em>
     * 
     * === Options:
     * MBT_LEFT ::
     *   
     * MBT_MIDDLE ::
     *   
     * MBT_RIGHT ::
     *   
     * 
     * @method _enum_MouseButtonType_
     * @return [Symbol]
     * @scope class
     */
    public enum MouseButtonType implements EnumMapper.IntegerEnum {
        MBT_LEFT(0),
        MBT_MIDDLE(1),
        MBT_RIGHT(2)
        ;
        
        private int nativeInt;
        
        private MouseButtonType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) X coordinate relative to the left side of the view.
     * :y ::
     *   (Integer) Y coordinate relative to the top side of the view.
     * :modifiers ::
     *   (Integer) Bit flags describing any pressed modifier keys. See
     *   cef_event_flags_t for values.
     */
    public static final class MouseEvent extends Struct {
        public Signed32 x = new Signed32();
        public Signed32 y = new Signed32();
        public Unsigned32 modifiers = new Unsigned32();
        public MouseEvent(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PaintElementType).</em>
     * 
     * === Options:
     * PET_VIEW ::
     *   
     * PET_POPUP ::
     *   
     * 
     * @method _enum_PaintElementType_
     * @return [Symbol]
     * @scope class
     */
    public enum PaintElementType implements EnumMapper.IntegerEnum {
        PET_VIEW(0),
        PET_POPUP(1)
        ;
        
        private int nativeInt;
        
        private PaintElementType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:EventFlags).</em>
     * 
     * === Options:
     * EVENTFLAG_NONE ::
     *   
     * EVENTFLAG_CAPS_LOCK_ON ::
     *   
     * EVENTFLAG_SHIFT_DOWN ::
     *   
     * EVENTFLAG_CONTROL_DOWN ::
     *   
     * EVENTFLAG_ALT_DOWN ::
     *   
     * EVENTFLAG_LEFT_MOUSE_BUTTON ::
     *   
     * EVENTFLAG_MIDDLE_MOUSE_BUTTON ::
     *   
     * EVENTFLAG_RIGHT_MOUSE_BUTTON ::
     *   
     * EVENTFLAG_COMMAND_DOWN ::
     *   Mac OS-X command key.
     * EVENTFLAG_NUM_LOCK_ON ::
     *   
     * EVENTFLAG_IS_KEY_PAD ::
     *   
     * EVENTFLAG_IS_LEFT ::
     *   
     * EVENTFLAG_IS_RIGHT ::
     *   
     * 
     * @method _enum_EventFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum EventFlags implements EnumMapper.IntegerEnum {
        EVENTFLAG_NONE(0),
        EVENTFLAG_CAPS_LOCK_ON(1),
        EVENTFLAG_SHIFT_DOWN(2),
        EVENTFLAG_CONTROL_DOWN(4),
        EVENTFLAG_ALT_DOWN(8),
        EVENTFLAG_LEFT_MOUSE_BUTTON(16),
        EVENTFLAG_MIDDLE_MOUSE_BUTTON(32),
        EVENTFLAG_RIGHT_MOUSE_BUTTON(64),
        EVENTFLAG_COMMAND_DOWN(128),
        EVENTFLAG_NUM_LOCK_ON(256),
        EVENTFLAG_IS_KEY_PAD(512),
        EVENTFLAG_IS_LEFT(1024),
        EVENTFLAG_IS_RIGHT(2048)
        ;
        
        private int nativeInt;
        
        private EventFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MenuItemType).</em>
     * 
     * === Options:
     * MENUITEMTYPE_NONE ::
     *   
     * MENUITEMTYPE_COMMAND ::
     *   
     * MENUITEMTYPE_CHECK ::
     *   
     * MENUITEMTYPE_RADIO ::
     *   
     * MENUITEMTYPE_SEPARATOR ::
     *   
     * MENUITEMTYPE_SUBMENU ::
     *   
     * 
     * @method _enum_MenuItemType_
     * @return [Symbol]
     * @scope class
     */
    public enum MenuItemType implements EnumMapper.IntegerEnum {
        MENUITEMTYPE_NONE(0),
        MENUITEMTYPE_COMMAND(1),
        MENUITEMTYPE_CHECK(2),
        MENUITEMTYPE_RADIO(3),
        MENUITEMTYPE_SEPARATOR(4),
        MENUITEMTYPE_SUBMENU(5)
        ;
        
        private int nativeInt;
        
        private MenuItemType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuTypeFlags).</em>
     * 
     * === Options:
     * CM_TYPEFLAG_NONE ::
     *   No node is selected.
     * CM_TYPEFLAG_PAGE ::
     *   The top page is selected.
     * CM_TYPEFLAG_FRAME ::
     *   A subframe page is selected.
     * CM_TYPEFLAG_LINK ::
     *   A link is selected.
     * CM_TYPEFLAG_MEDIA ::
     *   A media node is selected.
     * CM_TYPEFLAG_SELECTION ::
     *   There is a textual or mixed selection that is selected.
     * CM_TYPEFLAG_EDITABLE ::
     *   An editable element is selected.
     * 
     * @method _enum_ContextMenuTypeFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuTypeFlags implements EnumMapper.IntegerEnum {
        CM_TYPEFLAG_NONE(0),
        CM_TYPEFLAG_PAGE(1),
        CM_TYPEFLAG_FRAME(2),
        CM_TYPEFLAG_LINK(4),
        CM_TYPEFLAG_MEDIA(8),
        CM_TYPEFLAG_SELECTION(16),
        CM_TYPEFLAG_EDITABLE(32)
        ;
        
        private int nativeInt;
        
        private ContextMenuTypeFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuMediaType).</em>
     * 
     * === Options:
     * CM_MEDIATYPE_NONE ::
     *   No special node is in context.
     * CM_MEDIATYPE_IMAGE ::
     *   An image node is selected.
     * CM_MEDIATYPE_VIDEO ::
     *   A video node is selected.
     * CM_MEDIATYPE_AUDIO ::
     *   An audio node is selected.
     * CM_MEDIATYPE_FILE ::
     *   A file node is selected.
     * CM_MEDIATYPE_PLUGIN ::
     *   A plugin node is selected.
     * 
     * @method _enum_ContextMenuMediaType_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuMediaType implements EnumMapper.IntegerEnum {
        CM_MEDIATYPE_NONE(0),
        CM_MEDIATYPE_IMAGE(1),
        CM_MEDIATYPE_VIDEO(2),
        CM_MEDIATYPE_AUDIO(3),
        CM_MEDIATYPE_FILE(4),
        CM_MEDIATYPE_PLUGIN(5)
        ;
        
        private int nativeInt;
        
        private ContextMenuMediaType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuMediaStateFlags).</em>
     * 
     * === Options:
     * CM_MEDIAFLAG_NONE ::
     *   
     * CM_MEDIAFLAG_ERROR ::
     *   
     * CM_MEDIAFLAG_PAUSED ::
     *   
     * CM_MEDIAFLAG_MUTED ::
     *   
     * CM_MEDIAFLAG_LOOP ::
     *   
     * CM_MEDIAFLAG_CAN_SAVE ::
     *   
     * CM_MEDIAFLAG_HAS_AUDIO ::
     *   
     * CM_MEDIAFLAG_HAS_VIDEO ::
     *   
     * CM_MEDIAFLAG_CONTROL_ROOT_ELEMENT ::
     *   
     * CM_MEDIAFLAG_CAN_PRINT ::
     *   
     * CM_MEDIAFLAG_CAN_ROTATE ::
     *   
     * 
     * @method _enum_ContextMenuMediaStateFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuMediaStateFlags implements EnumMapper.IntegerEnum {
        CM_MEDIAFLAG_NONE(0),
        CM_MEDIAFLAG_ERROR(1),
        CM_MEDIAFLAG_PAUSED(2),
        CM_MEDIAFLAG_MUTED(4),
        CM_MEDIAFLAG_LOOP(8),
        CM_MEDIAFLAG_CAN_SAVE(16),
        CM_MEDIAFLAG_HAS_AUDIO(32),
        CM_MEDIAFLAG_HAS_VIDEO(64),
        CM_MEDIAFLAG_CONTROL_ROOT_ELEMENT(128),
        CM_MEDIAFLAG_CAN_PRINT(256),
        CM_MEDIAFLAG_CAN_ROTATE(512)
        ;
        
        private int nativeInt;
        
        private ContextMenuMediaStateFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ContextMenuEditStateFlags).</em>
     * 
     * === Options:
     * CM_EDITFLAG_NONE ::
     *   
     * CM_EDITFLAG_CAN_UNDO ::
     *   
     * CM_EDITFLAG_CAN_REDO ::
     *   
     * CM_EDITFLAG_CAN_CUT ::
     *   
     * CM_EDITFLAG_CAN_COPY ::
     *   
     * CM_EDITFLAG_CAN_PASTE ::
     *   
     * CM_EDITFLAG_CAN_DELETE ::
     *   
     * CM_EDITFLAG_CAN_SELECT_ALL ::
     *   
     * CM_EDITFLAG_CAN_TRANSLATE ::
     *   
     * 
     * @method _enum_ContextMenuEditStateFlags_
     * @return [Symbol]
     * @scope class
     */
    public enum ContextMenuEditStateFlags implements EnumMapper.IntegerEnum {
        CM_EDITFLAG_NONE(0),
        CM_EDITFLAG_CAN_UNDO(1),
        CM_EDITFLAG_CAN_REDO(2),
        CM_EDITFLAG_CAN_CUT(4),
        CM_EDITFLAG_CAN_COPY(8),
        CM_EDITFLAG_CAN_PASTE(16),
        CM_EDITFLAG_CAN_DELETE(32),
        CM_EDITFLAG_CAN_SELECT_ALL(64),
        CM_EDITFLAG_CAN_TRANSLATE(128)
        ;
        
        private int nativeInt;
        
        private ContextMenuEditStateFlags(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:KeyEventType).</em>
     * 
     * === Options:
     * KEYEVENT_RAWKEYDOWN ::
     *   Notification that a key transitioned from "up" to "down".
     * KEYEVENT_KEYDOWN ::
     *   Notification that a key was pressed. This does not necessarily correspond
     *   to a character depending on the key and language. Use KEYEVENT_CHAR for
     *   character input.
     * KEYEVENT_KEYUP ::
     *   Notification that a key was released.
     * KEYEVENT_CHAR ::
     *   Notification that a character was typed. Use this for text input. Key
     *   down events may generate 0, 1, or more than one character event depending
     *   on the key, locale, and operating system.
     * 
     * @method _enum_KeyEventType_
     * @return [Symbol]
     * @scope class
     */
    public enum KeyEventType implements EnumMapper.IntegerEnum {
        KEYEVENT_RAWKEYDOWN(0),
        KEYEVENT_KEYDOWN(1),
        KEYEVENT_KEYUP(2),
        KEYEVENT_CHAR(3)
        ;
        
        private int nativeInt;
        
        private KeyEventType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :type ::
     *   (Symbol from _enum_KeyEventType_) The type of keyboard event.
     * :modifiers ::
     *   (Integer) Bit flags describing any pressed modifier keys. See
     *   cef_event_flags_t for values.
     * :windowsKeyCode ::
     *   (Integer) The Windows key code for the key event. This value is used by the DOM
     *   specification. Sometimes it comes directly from the event (i.e. on
     *   Windows) and sometimes it's determined using a mapping function. See
     *   WebCore/platform/chromium/KeyboardCodes.h for the list of values.
     * :nativeKeyCode ::
     *   (Integer) The actual key code genenerated by the platform.
     * :isSystemKey ::
     *   (Integer) Indicates whether the event is considered a "system key" event (see
     *   http://msdn.microsoft.com/en-us/library/ms646286(VS.85).aspx for details).
     *   This value will always be false on non-Windows platforms.
     * :character ::
     *   (Integer) The character generated by the keystroke.
     * :unmodifiedCharacter ::
     *   (Integer) Same as |character| but unmodified by any concurrently-held modifiers
     *   (except shift). This is useful for working out shortcut keys.
     * :focusOnEditableField ::
     *   (Integer) True if the focus is currently on an editable field on the page. This is
     *   useful for determining if standard key events should be intercepted.
     */
    public static final class KeyEvent extends Struct {
        public Enum<KeyEventType> type = new Enum<>(KeyEventType.class);
        public Unsigned32 modifiers = new Unsigned32();
        public Signed32 windowsKeyCode = new Signed32();
        public Signed32 nativeKeyCode = new Signed32();
        public Signed32 isSystemKey = new Signed32();
        public Unsigned16 character = new Unsigned16();
        public Unsigned16 unmodifiedCharacter = new Unsigned16();
        public Signed32 focusOnEditableField = new Signed32();
        public KeyEvent(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:FocusSource).</em>
     * 
     * === Options:
     * NAVIGATION ::
     *   The source is explicit navigation via the API (LoadURL(), etc).
     * SYSTEM ::
     *   The source is a system-generated focus event.
     * 
     * @method _enum_FocusSource_
     * @return [Symbol]
     * @scope class
     */
    public enum FocusSource implements EnumMapper.IntegerEnum {
        NAVIGATION(0),
        SYSTEM(1)
        ;
        
        private int nativeInt;
        
        private FocusSource(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:NavigationType).</em>
     * 
     * === Options:
     * LINK_CLICKED ::
     *   
     * FORM_SUBMITTED ::
     *   
     * BACK_FORWARD ::
     *   
     * RELOAD ::
     *   
     * FORM_RESUBMITTED ::
     *   
     * OTHER ::
     *   
     * 
     * @method _enum_NavigationType_
     * @return [Symbol]
     * @scope class
     */
    public enum NavigationType implements EnumMapper.IntegerEnum {
        LINK_CLICKED(0),
        FORM_SUBMITTED(1),
        BACK_FORWARD(2),
        RELOAD(3),
        FORM_RESUBMITTED(4),
        OTHER(5)
        ;
        
        private int nativeInt;
        
        private NavigationType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:XmlEncodingType).</em>
     * 
     * === Options:
     * NONE ::
     *   
     * UTF8 ::
     *   
     * UTF16LE ::
     *   
     * UTF16BE ::
     *   
     * ASCII ::
     *   
     * 
     * @method _enum_XmlEncodingType_
     * @return [Symbol]
     * @scope class
     */
    public enum XmlEncodingType implements EnumMapper.IntegerEnum {
        NONE(0),
        UTF8(1),
        UTF16LE(2),
        UTF16BE(3),
        ASCII(4)
        ;
        
        private int nativeInt;
        
        private XmlEncodingType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:XmlNodeType).</em>
     * 
     * === Options:
     * UNSUPPORTED ::
     *   
     * PROCESSING_INSTRUCTION ::
     *   
     * DOCUMENT_TYPE ::
     *   
     * ELEMENT_START ::
     *   
     * ELEMENT_END ::
     *   
     * ATTRIBUTE ::
     *   
     * TEXT ::
     *   
     * CDATA ::
     *   
     * ENTITY_REFERENCE ::
     *   
     * WHITESPACE ::
     *   
     * COMMENT ::
     *   
     * 
     * @method _enum_XmlNodeType_
     * @return [Symbol]
     * @scope class
     */
    public enum XmlNodeType implements EnumMapper.IntegerEnum {
        UNSUPPORTED(0),
        PROCESSING_INSTRUCTION(1),
        DOCUMENT_TYPE(2),
        ELEMENT_START(3),
        ELEMENT_END(4),
        ATTRIBUTE(5),
        TEXT(6),
        CDATA(7),
        ENTITY_REFERENCE(8),
        WHITESPACE(9),
        COMMENT(10)
        ;
        
        private int nativeInt;
        
        private XmlNodeType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :x ::
     *   (Integer) 
     * :xSet ::
     *   (Integer) 
     * :y ::
     *   (Integer) 
     * :ySet ::
     *   (Integer) 
     * :width ::
     *   (Integer) 
     * :widthSet ::
     *   (Integer) 
     * :height ::
     *   (Integer) 
     * :heightSet ::
     *   (Integer) 
     * :menuBarVisible ::
     *   (Integer) 
     * :statusBarVisible ::
     *   (Integer) 
     * :toolBarVisible ::
     *   (Integer) 
     * :locationBarVisible ::
     *   (Integer) 
     * :scrollbarsVisible ::
     *   (Integer) 
     * :resizable ::
     *   (Integer) 
     * :fullscreen ::
     *   (Integer) 
     * :dialog ::
     *   (Integer) 
     */
    public static final class PopupFeatures extends Struct {
        public Signed32 x = new Signed32();
        public Signed32 xSet = new Signed32();
        public Signed32 y = new Signed32();
        public Signed32 ySet = new Signed32();
        public Signed32 width = new Signed32();
        public Signed32 widthSet = new Signed32();
        public Signed32 height = new Signed32();
        public Signed32 heightSet = new Signed32();
        public Signed32 menuBarVisible = new Signed32();
        public Signed32 statusBarVisible = new Signed32();
        public Signed32 toolBarVisible = new Signed32();
        public Signed32 locationBarVisible = new Signed32();
        public Signed32 scrollbarsVisible = new Signed32();
        public Signed32 resizable = new Signed32();
        public Signed32 fullscreen = new Signed32();
        public Signed32 dialog = new Signed32();
        public PopupFeatures(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomDocumentType).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * HTML ::
     *   
     * XHTML ::
     *   
     * PLUGIN ::
     *   
     * 
     * @method _enum_DomDocumentType_
     * @return [Symbol]
     * @scope class
     */
    public enum DomDocumentType implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        HTML(1),
        XHTML(2),
        PLUGIN(3)
        ;
        
        private int nativeInt;
        
        private DomDocumentType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomEventCategory).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * UI ::
     *   
     * MOUSE ::
     *   
     * MUTATION ::
     *   
     * KEYBOARD ::
     *   
     * TEXT ::
     *   
     * COMPOSITION ::
     *   
     * DRAG ::
     *   
     * CLIPBOARD ::
     *   
     * MESSAGE ::
     *   
     * WHEEL ::
     *   
     * BEFORE_TEXT_INSERTED ::
     *   
     * OVERFLOW ::
     *   
     * PAGE_TRANSITION ::
     *   
     * POPSTATE ::
     *   
     * PROGRESS ::
     *   
     * XMLHTTPREQUEST_PROGRESS ::
     *   
     * 
     * @method _enum_DomEventCategory_
     * @return [Symbol]
     * @scope class
     */
    public enum DomEventCategory implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        UI(1),
        MOUSE(2),
        MUTATION(4),
        KEYBOARD(8),
        TEXT(16),
        COMPOSITION(32),
        DRAG(64),
        CLIPBOARD(128),
        MESSAGE(256),
        WHEEL(512),
        BEFORE_TEXT_INSERTED(1024),
        OVERFLOW(2048),
        PAGE_TRANSITION(4096),
        POPSTATE(8192),
        PROGRESS(16384),
        XMLHTTPREQUEST_PROGRESS(32768)
        ;
        
        private int nativeInt;
        
        private DomEventCategory(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomEventPhase).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * CAPTURING ::
     *   
     * AT_TARGET ::
     *   
     * BUBBLING ::
     *   
     * 
     * @method _enum_DomEventPhase_
     * @return [Symbol]
     * @scope class
     */
    public enum DomEventPhase implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        CAPTURING(1),
        AT_TARGET(2),
        BUBBLING(3)
        ;
        
        private int nativeInt;
        
        private DomEventPhase(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DomNodeType).</em>
     * 
     * === Options:
     * UNSUPPORTED ::
     *   
     * ELEMENT ::
     *   
     * ATTRIBUTE ::
     *   
     * TEXT ::
     *   
     * CDATA_SECTION ::
     *   
     * PROCESSING_INSTRUCTIONS ::
     *   
     * COMMENT ::
     *   
     * DOCUMENT ::
     *   
     * DOCUMENT_TYPE ::
     *   
     * DOCUMENT_FRAGMENT ::
     *   
     * 
     * @method _enum_DomNodeType_
     * @return [Symbol]
     * @scope class
     */
    public enum DomNodeType implements EnumMapper.IntegerEnum {
        UNSUPPORTED(0),
        ELEMENT(1),
        ATTRIBUTE(2),
        TEXT(3),
        CDATA_SECTION(4),
        PROCESSING_INSTRUCTIONS(5),
        COMMENT(6),
        DOCUMENT(7),
        DOCUMENT_TYPE(8),
        DOCUMENT_FRAGMENT(9)
        ;
        
        private int nativeInt;
        
        private DomNodeType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:FileDialogMode).</em>
     * 
     * === Options:
     * OPEN ::
     *   Requires that the file exists before allowing the user to pick it.
     * OPEN_MULTIPLE ::
     *   Like Open, but allows picking multiple files to open.
     * OPEN_FOLDER ::
     *   Like Open, but selects a folder to open.
     * SAVE ::
     *   Allows picking a nonexistent file, and prompts to overwrite if the file
     *   already exists.
     * TYPE_MASK ::
     *   General mask defining the bits used for the type values.
     * OVERWRITEPROMPT_FLAG ::
     *   Prompt to overwrite if the user selects an existing file with the Save
     *   dialog.
     * HIDEREADONLY_FLAG ::
     *   Do not display read-only files.
     * 
     * @method _enum_FileDialogMode_
     * @return [Symbol]
     * @scope class
     */
    public enum FileDialogMode implements EnumMapper.IntegerEnum {
        OPEN(0),
        OPEN_MULTIPLE(1),
        OPEN_FOLDER(2),
        SAVE(3),
        TYPE_MASK(255),
        OVERWRITEPROMPT_FLAG(16777216),
        HIDEREADONLY_FLAG(33554432)
        ;
        
        private int nativeInt;
        
        private FileDialogMode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:GeopositionErrorCode).</em>
     * 
     * === Options:
     * GEOPOSITON_ERROR_NONE ::
     *   
     * GEOPOSITON_ERROR_PERMISSION_DENIED ::
     *   
     * GEOPOSITON_ERROR_POSITION_UNAVAILABLE ::
     *   
     * GEOPOSITON_ERROR_TIMEOUT ::
     *   
     * 
     * @method _enum_GeopositionErrorCode_
     * @return [Symbol]
     * @scope class
     */
    public enum GeopositionErrorCode implements EnumMapper.IntegerEnum {
        GEOPOSITON_ERROR_NONE(0),
        GEOPOSITON_ERROR_PERMISSION_DENIED(1),
        GEOPOSITON_ERROR_POSITION_UNAVAILABLE(2),
        GEOPOSITON_ERROR_TIMEOUT(3)
        ;
        
        private int nativeInt;
        
        private GeopositionErrorCode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :latitude ::
     *   (Float) Latitude in decimal degrees north (WGS84 coordinate frame).
     * :longitude ::
     *   (Float) Longitude in decimal degrees west (WGS84 coordinate frame).
     * :altitude ::
     *   (Float) Altitude in meters (above WGS84 datum).
     * :accuracy ::
     *   (Float) Accuracy of horizontal position in meters.
     * :altitudeAccuracy ::
     *   (Float) Accuracy of altitude in meters.
     * :heading ::
     *   (Float) Heading in decimal degrees clockwise from true north.
     * :speed ::
     *   (Float) Horizontal component of device velocity in meters per second.
     * :timestamp ::
     *   (unknown) Time of position measurement in milliseconds since Epoch in UTC time. This
     *   is taken from the host computer's system clock.
     * :errorCode ::
     *   (Symbol from _enum_GeopositionErrorCode_) Error code, see enum above.
     * :errorMessage ::
     *   (StringUtf16) Human-readable error message.
     */
    public static final class Geoposition extends Struct {
        public Double latitude = new Double();
        public Double longitude = new Double();
        public Double altitude = new Double();
        public Double accuracy = new Double();
        public Double altitudeAccuracy = new Double();
        public Double heading = new Double();
        public Double speed = new Double();
        public Pointer timestamp = new Pointer();
        public Enum<GeopositionErrorCode> errorCode = new Enum<>(GeopositionErrorCode.class);
        public StringUtf16 errorMessage = inner(new StringUtf16(getRuntime()));
        public Geoposition(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ColorModel).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * GRAY ::
     *   
     * COLOR ::
     *   
     * CMYK ::
     *   
     * CMY ::
     *   
     * KCMY ::
     *   
     * CMY_K ::
     *   
     * BLACK ::
     *   CMY_K represents CMY+K.
     * GRAYSCALE ::
     *   
     * RGB ::
     *   
     * RGB16 ::
     *   
     * RGBA ::
     *   
     * COLORMODE_COLOR ::
     *   
     * COLORMODE_MONOCHROME ::
     *   Used in samsung printer ppds.
     * HP_COLOR_COLOR ::
     *   Used in samsung printer ppds.
     * HP_COLOR_BLACK ::
     *   Used in HP color printer ppds.
     * PRINTOUTMODE_NORMAL ::
     *   Used in HP color printer ppds.
     * PRINTOUTMODE_NORMAL_GRAY ::
     *   Used in foomatic ppds.
     * PROCESSCOLORMODEL_CMYK ::
     *   Used in foomatic ppds.
     * PROCESSCOLORMODEL_GREYSCALE ::
     *   Used in canon printer ppds.
     * PROCESSCOLORMODEL_RGB ::
     *   Used in canon printer ppds.
     * 
     * @method _enum_ColorModel_
     * @return [Symbol]
     * @scope class
     */
    public enum ColorModel implements EnumMapper.IntegerEnum {
        UNKNOWN(0),
        GRAY(1),
        COLOR(2),
        CMYK(3),
        CMY(4),
        KCMY(5),
        CMY_K(6),
        BLACK(7),
        GRAYSCALE(8),
        RGB(9),
        RGB16(10),
        RGBA(11),
        COLORMODE_COLOR(12),
        COLORMODE_MONOCHROME(13),
        HP_COLOR_COLOR(14),
        HP_COLOR_BLACK(15),
        PRINTOUTMODE_NORMAL(16),
        PRINTOUTMODE_NORMAL_GRAY(17),
        PROCESSCOLORMODEL_CMYK(18),
        PROCESSCOLORMODEL_GREYSCALE(19),
        PROCESSCOLORMODEL_RGB(20)
        ;
        
        private int nativeInt;
        
        private ColorModel(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:DuplexMode).</em>
     * 
     * === Options:
     * UNKNOWN ::
     *   
     * SIMPLEX ::
     *   
     * LONG_EDGE ::
     *   
     * SHORT_EDGE ::
     *   
     * 
     * @method _enum_DuplexMode_
     * @return [Symbol]
     * @scope class
     */
    public enum DuplexMode implements EnumMapper.IntegerEnum {
        UNKNOWN(-1),
        SIMPLEX(0),
        LONG_EDGE(1),
        SHORT_EDGE(2)
        ;
        
        private int nativeInt;
        
        private DuplexMode(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:CursorType).</em>
     * 
     * === Options:
     * CT_POINTER ::
     *   
     * CT_CROSS ::
     *   
     * CT_HAND ::
     *   
     * CT_IBEAM ::
     *   
     * CT_WAIT ::
     *   
     * CT_HELP ::
     *   
     * CT_EASTRESIZE ::
     *   
     * CT_NORTHRESIZE ::
     *   
     * CT_NORTHEASTRESIZE ::
     *   
     * CT_NORTHWESTRESIZE ::
     *   
     * CT_SOUTHRESIZE ::
     *   
     * CT_SOUTHEASTRESIZE ::
     *   
     * CT_SOUTHWESTRESIZE ::
     *   
     * CT_WESTRESIZE ::
     *   
     * CT_NORTHSOUTHRESIZE ::
     *   
     * CT_EASTWESTRESIZE ::
     *   
     * CT_NORTHEASTSOUTHWESTRESIZE ::
     *   
     * CT_NORTHWESTSOUTHEASTRESIZE ::
     *   
     * CT_COLUMNRESIZE ::
     *   
     * CT_ROWRESIZE ::
     *   
     * CT_MIDDLEPANNING ::
     *   
     * CT_EASTPANNING ::
     *   
     * CT_NORTHPANNING ::
     *   
     * CT_NORTHEASTPANNING ::
     *   
     * CT_NORTHWESTPANNING ::
     *   
     * CT_SOUTHPANNING ::
     *   
     * CT_SOUTHEASTPANNING ::
     *   
     * CT_SOUTHWESTPANNING ::
     *   
     * CT_WESTPANNING ::
     *   
     * CT_MOVE ::
     *   
     * CT_VERTICALTEXT ::
     *   
     * CT_CELL ::
     *   
     * CT_CONTEXTMENU ::
     *   
     * CT_ALIAS ::
     *   
     * CT_PROGRESS ::
     *   
     * CT_NODROP ::
     *   
     * CT_COPY ::
     *   
     * CT_NONE ::
     *   
     * CT_NOTALLOWED ::
     *   
     * CT_ZOOMIN ::
     *   
     * CT_ZOOMOUT ::
     *   
     * CT_GRAB ::
     *   
     * CT_GRABBING ::
     *   
     * CT_CUSTOM ::
     *   
     * 
     * @method _enum_CursorType_
     * @return [Symbol]
     * @scope class
     */
    public enum CursorType implements EnumMapper.IntegerEnum {
        CT_POINTER(0),
        CT_CROSS(1),
        CT_HAND(2),
        CT_IBEAM(3),
        CT_WAIT(4),
        CT_HELP(5),
        CT_EASTRESIZE(6),
        CT_NORTHRESIZE(7),
        CT_NORTHEASTRESIZE(8),
        CT_NORTHWESTRESIZE(9),
        CT_SOUTHRESIZE(10),
        CT_SOUTHEASTRESIZE(11),
        CT_SOUTHWESTRESIZE(12),
        CT_WESTRESIZE(13),
        CT_NORTHSOUTHRESIZE(14),
        CT_EASTWESTRESIZE(15),
        CT_NORTHEASTSOUTHWESTRESIZE(16),
        CT_NORTHWESTSOUTHEASTRESIZE(17),
        CT_COLUMNRESIZE(18),
        CT_ROWRESIZE(19),
        CT_MIDDLEPANNING(20),
        CT_EASTPANNING(21),
        CT_NORTHPANNING(22),
        CT_NORTHEASTPANNING(23),
        CT_NORTHWESTPANNING(24),
        CT_SOUTHPANNING(25),
        CT_SOUTHEASTPANNING(26),
        CT_SOUTHWESTPANNING(27),
        CT_WESTPANNING(28),
        CT_MOVE(29),
        CT_VERTICALTEXT(30),
        CT_CELL(31),
        CT_CONTEXTMENU(32),
        CT_ALIAS(33),
        CT_PROGRESS(34),
        CT_NODROP(35),
        CT_COPY(36),
        CT_NONE(37),
        CT_NOTALLOWED(38),
        CT_ZOOMIN(39),
        CT_ZOOMOUT(40),
        CT_GRAB(41),
        CT_GRABBING(42),
        CT_CUSTOM(43)
        ;
        
        private int nativeInt;
        
        private CursorType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :hotspot ::
     *   (Point) 
     * :imageScaleFactor ::
     *   (Float) 
     * :buffer ::
     *   (FFI::Pointer(*Void)) 
     * :size ::
     *   (Size) 
     */
    public static final class CursorInfo extends Struct {
        public Point hotspot = inner(new Point(getRuntime()));
        public Float imageScaleFactor = new Float();
        public Pointer buffer = new Pointer();
        public Size size = inner(new Size(getRuntime()));
        public CursorInfo(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:UriUnescapeRule).</em>
     * 
     * === Options:
     * UU_NONE ::
     *   Don't unescape anything at all.
     * UU_NORMAL ::
     *   Don't unescape anything special, but all normal unescaping will happen.
     *   This is a placeholder and can't be combined with other flags (since it's
     *   just the absence of them). All other unescape rules imply "normal" in
     *   addition to their special meaning. Things like escaped letters, digits,
     *   and most symbols will get unescaped with this mode.
     * UU_SPACES ::
     *   Convert %20 to spaces. In some places where we're showing URLs, we may
     *   want this. In places where the URL may be copied and pasted out, then
     *   you wouldn't want this since it might not be interpreted in one piece
     *   by other applications.
     * UU_PATH_SEPARATORS ::
     *   Unescapes '/' and '\\'. If these characters were unescaped, the resulting
     *   URL won't be the same as the source one. Moreover, they are dangerous to
     *   unescape in strings that will be used as file paths or names. This value
     *   should only be used when slashes don't have special meaning, like data
     *   URLs.
     * UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS ::
     *   Unescapes various characters that will change the meaning of URLs,
     *   including '%', '+', '&', '#'. Does not unescape path separators.
     *   If these characters were unescaped, the resulting URL won't be the same
     *   as the source one. This flag is used when generating final output like
     *   filenames for URLs where we won't be interpreting as a URL and want to do
     *   as much unescaping as possible.
     * UU_SPOOFING_AND_CONTROL_CHARS ::
     *   Unescapes characters that can be used in spoofing attempts (such as LOCK)
     *   and control characters (such as BiDi control characters and %01).  This
     *   INCLUDES NULLs.  This is used for rare cases such as data: URL decoding
     *   where the result is binary data.
     *   
     *   DO NOT use UU_SPOOFING_AND_CONTROL_CHARS if the URL is going to be
     *   displayed in the UI for security reasons.
     * UU_REPLACE_PLUS_WITH_SPACE ::
     *   URL queries use "+" for space. This flag controls that replacement.
     * 
     * @method _enum_UriUnescapeRule_
     * @return [Symbol]
     * @scope class
     */
    public enum UriUnescapeRule implements EnumMapper.IntegerEnum {
        UU_NONE(0),
        UU_NORMAL(1),
        UU_SPACES(2),
        UU_PATH_SEPARATORS(4),
        UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS(8),
        UU_SPOOFING_AND_CONTROL_CHARS(16),
        UU_REPLACE_PLUS_WITH_SPACE(32)
        ;
        
        private int nativeInt;
        
        private UriUnescapeRule(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsonParserOptions).</em>
     * 
     * === Options:
     * RFC ::
     *   Parses the input strictly according to RFC 4627. See comments in Chromium's
     *   base/json/json_reader.h file for known limitations/deviations from the RFC.
     * ALLOW_TRAILING_COMMAS ::
     *   Allows commas to exist after the last element in structures.
     * 
     * @method _enum_JsonParserOptions_
     * @return [Symbol]
     * @scope class
     */
    public enum JsonParserOptions implements EnumMapper.IntegerEnum {
        RFC(0),
        ALLOW_TRAILING_COMMAS(1)
        ;
        
        private int nativeInt;
        
        private JsonParserOptions(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsonParserError).</em>
     * 
     * === Options:
     * NO_ERROR ::
     *   
     * INVALID_ESCAPE ::
     *   
     * SYNTAX_ERROR ::
     *   
     * UNEXPECTED_TOKEN ::
     *   
     * TRAILING_COMMA ::
     *   
     * TOO_MUCH_NESTING ::
     *   
     * UNEXPECTED_DATA_AFTER_ROOT ::
     *   
     * UNSUPPORTED_ENCODING ::
     *   
     * UNQUOTED_DICTIONARY_KEY ::
     *   
     * PARSE_ERROR_COUNT ::
     *   
     * 
     * @method _enum_JsonParserError_
     * @return [Symbol]
     * @scope class
     */
    public enum JsonParserError implements EnumMapper.IntegerEnum {
        NO_ERROR(0),
        INVALID_ESCAPE(1),
        SYNTAX_ERROR(2),
        UNEXPECTED_TOKEN(3),
        TRAILING_COMMA(4),
        TOO_MUCH_NESTING(5),
        UNEXPECTED_DATA_AFTER_ROOT(6),
        UNSUPPORTED_ENCODING(7),
        UNQUOTED_DICTIONARY_KEY(8),
        PARSE_ERROR_COUNT(9)
        ;
        
        private int nativeInt;
        
        private JsonParserError(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:JsonWriterOptions).</em>
     * 
     * === Options:
     * DEFAULT ::
     *   Default behavior.
     * OMIT_BINARY_VALUES ::
     *   This option instructs the writer that if a Binary value is encountered,
     *   the value (and key if within a dictionary) will be omitted from the
     *   output, and success will be returned. Otherwise, if a binary value is
     *   encountered, failure will be returned.
     * OMIT_DOUBLE_TYPE_PRESERVATION ::
     *   This option instructs the writer to write doubles that have no fractional
     *   part as a normal integer (i.e., without using exponential notation
     *   or appending a '.0') as long as the value is within the range of a
     *   64-bit int.
     * PRETTY_PRINT ::
     *   Return a slightly nicer formatted json string (pads with whitespace to
     *   help with readability).
     * 
     * @method _enum_JsonWriterOptions_
     * @return [Symbol]
     * @scope class
     */
    public enum JsonWriterOptions implements EnumMapper.IntegerEnum {
        DEFAULT(0),
        OMIT_BINARY_VALUES(1),
        OMIT_DOUBLE_TYPE_PRESERVATION(2),
        PRETTY_PRINT(4)
        ;
        
        private int nativeInt;
        
        private JsonWriterOptions(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PdfPrintMarginType).</em>
     * 
     * === Options:
     * DEFAULT ::
     *   Default margins.
     * NONE ::
     *   No margins.
     * MINIMUM ::
     *   Minimum margins.
     * CUSTOM ::
     *   Custom margins using the |margin_*| values from cef_pdf_print_settings_t.
     * 
     * @method _enum_PdfPrintMarginType_
     * @return [Symbol]
     * @scope class
     */
    public enum PdfPrintMarginType implements EnumMapper.IntegerEnum {
        DEFAULT(0),
        NONE(1),
        MINIMUM(2),
        CUSTOM(3)
        ;
        
        private int nativeInt;
        
        private PdfPrintMarginType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :headerFooterTitle ::
     *   (StringUtf16) Page title to display in the header. Only used if |header_footer_enabled|
     *   is set to true (1).
     * :headerFooterUrl ::
     *   (StringUtf16) URL to display in the footer. Only used if |header_footer_enabled| is set
     *   to true (1).
     * :pageWidth ::
     *   (Integer) Output page size in microns. If either of these values is less than or
     *   equal to zero then the default paper size (A4) will be used.
     * :pageHeight ::
     *   (Integer) 
     * :scaleFactor ::
     *   (Integer) The percentage to scale the PDF by before printing (e.g. 50 is 50%).
     *   If this value is less than or equal to zero the default value of 100
     *   will be used.
     * :marginTop ::
     *   (Float) Margins in millimeters. Only used if |margin_type| is set to
     *   PDF_PRINT_MARGIN_CUSTOM.
     * :marginRight ::
     *   (Float) 
     * :marginBottom ::
     *   (Float) 
     * :marginLeft ::
     *   (Float) 
     * :marginType ::
     *   (Symbol from _enum_PdfPrintMarginType_) Margin type.
     * :headerFooterEnabled ::
     *   (Integer) Set to true (1) to print headers and footers or false (0) to not print
     *   headers and footers.
     * :selectionOnly ::
     *   (Integer) Set to true (1) to print the selection only or false (0) to print all.
     * :landscape ::
     *   (Integer) Set to true (1) for landscape mode or false (0) for portrait mode.
     * :backgroundsEnabled ::
     *   (Integer) Set to true (1) to print background graphics or false (0) to not print
     *   background graphics.
     */
    public static final class PdfPrintSettings extends Struct {
        public StringUtf16 headerFooterTitle = inner(new StringUtf16(getRuntime()));
        public StringUtf16 headerFooterUrl = inner(new StringUtf16(getRuntime()));
        public Signed32 pageWidth = new Signed32();
        public Signed32 pageHeight = new Signed32();
        public Signed32 scaleFactor = new Signed32();
        public Double marginTop = new Double();
        public Double marginRight = new Double();
        public Double marginBottom = new Double();
        public Double marginLeft = new Double();
        public Enum<PdfPrintMarginType> marginType = new Enum<>(PdfPrintMarginType.class);
        public Signed32 headerFooterEnabled = new Signed32();
        public Signed32 selectionOnly = new Signed32();
        public Signed32 landscape = new Signed32();
        public Signed32 backgroundsEnabled = new Signed32();
        public PdfPrintSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ScaleFactor).</em>
     * 
     * === Options:
     * NONE ::
     *   
     * _100P ::
     *   
     * _125P ::
     *   
     * _133P ::
     *   
     * _140P ::
     *   
     * _150P ::
     *   
     * _180P ::
     *   
     * _200P ::
     *   
     * _250P ::
     *   
     * _300P ::
     *   
     * 
     * @method _enum_ScaleFactor_
     * @return [Symbol]
     * @scope class
     */
    public enum ScaleFactor implements EnumMapper.IntegerEnum {
        NONE(0),
        _100P(1),
        _125P(2),
        _133P(3),
        _140P(4),
        _150P(5),
        _180P(6),
        _200P(7),
        _250P(8),
        _300P(9)
        ;
        
        private int nativeInt;
        
        private ScaleFactor(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:PluginPolicy).</em>
     * 
     * === Options:
     * ALLOW ::
     *   Allow the content.
     * DETECT_IMPORTANT ::
     *   Allow important content and block unimportant content based on heuristics.
     *   The user can manually load blocked content.
     * BLOCK ::
     *   Block the content. The user can manually load blocked content.
     * DISABLE ::
     *   Disable the content. The user cannot load disabled content.
     * 
     * @method _enum_PluginPolicy_
     * @return [Symbol]
     * @scope class
     */
    public enum PluginPolicy implements EnumMapper.IntegerEnum {
        ALLOW(0),
        DETECT_IMPORTANT(1),
        BLOCK(2),
        DISABLE(3)
        ;
        
        private int nativeInt;
        
        private PluginPolicy(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ReferrerPolicy).</em>
     * 
     * === Options:
     * ALWAYS ::
     *   Always send the complete Referrer value.
     * DEFAULT ::
     *   Use the default policy. This is REFERRER_POLICY_ORIGIN_WHEN_CROSS_ORIGIN
     *   when the `--reduced-referrer-granularity` command-line flag is specified
     *   and REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE otherwise.
     * NO_REFERRER_WHEN_DOWNGRADE ::
     *   When navigating from HTTPS to HTTP do not send the Referrer value.
     *   Otherwise, send the complete Referrer value.
     * NEVER ::
     *   Never send the Referrer value.
     * ORIGIN ::
     *   Only send the origin component of the Referrer value.
     * ORIGIN_WHEN_CROSS_ORIGIN ::
     *   When navigating cross-origin only send the origin component of the Referrer
     *   value. Otherwise, send the complete Referrer value.
     * 
     * @method _enum_ReferrerPolicy_
     * @return [Symbol]
     * @scope class
     */
    public enum ReferrerPolicy implements EnumMapper.IntegerEnum {
        ALWAYS(0),
        DEFAULT(1),
        NO_REFERRER_WHEN_DOWNGRADE(2),
        NEVER(3),
        ORIGIN(4),
        ORIGIN_WHEN_CROSS_ORIGIN(5)
        ;
        
        private int nativeInt;
        
        private ReferrerPolicy(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ResponseFilterStatus).</em>
     * 
     * === Options:
     * NEED_MORE_DATA ::
     *   Some or all of the pre-filter data was read successfully but more data is
     *   needed in order to continue filtering (filtered output is pending).
     * DONE ::
     *   Some or all of the pre-filter data was read successfully and all available
     *   filtered output has been written.
     * ERROR ::
     *   An error occurred during filtering.
     * 
     * @method _enum_ResponseFilterStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum ResponseFilterStatus implements EnumMapper.IntegerEnum {
        NEED_MORE_DATA(0),
        DONE(1),
        ERROR(2)
        ;
        
        private int nativeInt;
        
        private ResponseFilterStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ColorType).</em>
     * 
     * === Options:
     * RGBA_8888 ::
     *   RGBA with 8 bits per pixel (32bits total).
     * BGRA_8888 ::
     *   BGRA with 8 bits per pixel (32bits total).
     * 
     * @method _enum_ColorType_
     * @return [Symbol]
     * @scope class
     */
    public enum ColorType implements EnumMapper.IntegerEnum {
        RGBA_8888(0),
        BGRA_8888(1)
        ;
        
        private int nativeInt;
        
        private ColorType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:AlphaType).</em>
     * 
     * === Options:
     * OPAQUE ::
     *   No transparency. The alpha component is ignored.
     * PREMULTIPLIED ::
     *   Transparency with pre-multiplied alpha component.
     * POSTMULTIPLIED ::
     *   Transparency with post-multiplied alpha component.
     * 
     * @method _enum_AlphaType_
     * @return [Symbol]
     * @scope class
     */
    public enum AlphaType implements EnumMapper.IntegerEnum {
        OPAQUE(0),
        PREMULTIPLIED(1),
        POSTMULTIPLIED(2)
        ;
        
        private int nativeInt;
        
        private AlphaType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:TextStyle).</em>
     * 
     * === Options:
     * BOLD ::
     *   
     * ITALIC ::
     *   
     * STRIKE ::
     *   
     * DIAGONAL_STRIKE ::
     *   
     * UNDERLINE ::
     *   
     * 
     * @method _enum_TextStyle_
     * @return [Symbol]
     * @scope class
     */
    public enum TextStyle implements EnumMapper.IntegerEnum {
        BOLD(0),
        ITALIC(1),
        STRIKE(2),
        DIAGONAL_STRIKE(3),
        UNDERLINE(4)
        ;
        
        private int nativeInt;
        
        private TextStyle(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MainAxisAlignment).</em>
     * 
     * === Options:
     * START ::
     *   Child views will be left-aligned.
     * CENTER ::
     *   Child views will be center-aligned.
     * END ::
     *   Child views will be right-aligned.
     * 
     * @method _enum_MainAxisAlignment_
     * @return [Symbol]
     * @scope class
     */
    public enum MainAxisAlignment implements EnumMapper.IntegerEnum {
        START(0),
        CENTER(1),
        END(2)
        ;
        
        private int nativeInt;
        
        private MainAxisAlignment(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:CrossAxisAlignment).</em>
     * 
     * === Options:
     * STRETCH ::
     *   Child views will be stretched to fit.
     * START ::
     *   Child views will be left-aligned.
     * CENTER ::
     *   Child views will be center-aligned.
     * END ::
     *   Child views will be right-aligned.
     * 
     * @method _enum_CrossAxisAlignment_
     * @return [Symbol]
     * @scope class
     */
    public enum CrossAxisAlignment implements EnumMapper.IntegerEnum {
        STRETCH(0),
        START(1),
        CENTER(2),
        END(3)
        ;
        
        private int nativeInt;
        
        private CrossAxisAlignment(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :horizontal ::
     *   (Integer) If true (1) the layout will be horizontal, otherwise the layout will be
     *   vertical.
     * :insideBorderHorizontalSpacing ::
     *   (Integer) Adds additional horizontal space between the child view area and the host
     *   view border.
     * :insideBorderVerticalSpacing ::
     *   (Integer) Adds additional vertical space between the child view area and the host
     *   view border.
     * :insideBorderInsets ::
     *   (Insets) Adds additional space around the child view area.
     * :betweenChildSpacing ::
     *   (Integer) Adds additional space between child views.
     * :mainAxisAlignment ::
     *   (Symbol from _enum_MainAxisAlignment_) Specifies where along the main axis the child views should be laid out.
     * :crossAxisAlignment ::
     *   (Symbol from _enum_CrossAxisAlignment_) Specifies where along the cross axis the child views should be laid out.
     * :minimumCrossAxisSize ::
     *   (Integer) Minimum cross axis size.
     * :defaultFlex ::
     *   (Integer) Default flex for views when none is specified via CefBoxLayout methods.
     *   Using the preferred size as the basis, free space along the main axis is
     *   distributed to views in the ratio of their flex weights. Similarly, if the
     *   views will overflow the parent, space is subtracted in these ratios. A flex
     *   of 0 means this view is not resized. Flex values must not be negative.
     */
    public static final class BoxLayoutSettings extends Struct {
        public Signed32 horizontal = new Signed32();
        public Signed32 insideBorderHorizontalSpacing = new Signed32();
        public Signed32 insideBorderVerticalSpacing = new Signed32();
        public Insets insideBorderInsets = inner(new Insets(getRuntime()));
        public Signed32 betweenChildSpacing = new Signed32();
        public Enum<MainAxisAlignment> mainAxisAlignment = new Enum<>(MainAxisAlignment.class);
        public Enum<CrossAxisAlignment> crossAxisAlignment = new Enum<>(CrossAxisAlignment.class);
        public Signed32 minimumCrossAxisSize = new Signed32();
        public Signed32 defaultFlex = new Signed32();
        public BoxLayoutSettings(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:ButtonState).</em>
     * 
     * === Options:
     * NORMAL ::
     *   
     * HOVERED ::
     *   
     * PRESSED ::
     *   
     * DISABLED ::
     *   
     * 
     * @method _enum_ButtonState_
     * @return [Symbol]
     * @scope class
     */
    public enum ButtonState implements EnumMapper.IntegerEnum {
        NORMAL(0),
        HOVERED(1),
        PRESSED(2),
        DISABLED(3)
        ;
        
        private int nativeInt;
        
        private ButtonState(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:HorizontalAlignment).</em>
     * 
     * === Options:
     * LEFT ::
     *   Align the text's left edge with that of its display area.
     * CENTER ::
     *   Align the text's center with that of its display area.
     * RIGHT ::
     *   Align the text's right edge with that of its display area.
     * 
     * @method _enum_HorizontalAlignment_
     * @return [Symbol]
     * @scope class
     */
    public enum HorizontalAlignment implements EnumMapper.IntegerEnum {
        LEFT(0),
        CENTER(1),
        RIGHT(2)
        ;
        
        private int nativeInt;
        
        private HorizontalAlignment(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MenuAnchorPosition).</em>
     * 
     * === Options:
     * TOPLEFT ::
     *   
     * TOPRIGHT ::
     *   
     * BOTTOMCENTER ::
     *   
     * 
     * @method _enum_MenuAnchorPosition_
     * @return [Symbol]
     * @scope class
     */
    public enum MenuAnchorPosition implements EnumMapper.IntegerEnum {
        TOPLEFT(0),
        TOPRIGHT(1),
        BOTTOMCENTER(2)
        ;
        
        private int nativeInt;
        
        private MenuAnchorPosition(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:MenuColorType).</em>
     * 
     * === Options:
     * TEXT ::
     *   
     * TEXT_HOVERED ::
     *   
     * TEXT_ACCELERATOR ::
     *   
     * TEXT_ACCELERATOR_HOVERED ::
     *   
     * BACKGROUND ::
     *   
     * BACKGROUND_HOVERED ::
     *   
     * COUNT ::
     *   
     * 
     * @method _enum_MenuColorType_
     * @return [Symbol]
     * @scope class
     */
    public enum MenuColorType implements EnumMapper.IntegerEnum {
        TEXT(0),
        TEXT_HOVERED(1),
        TEXT_ACCELERATOR(2),
        TEXT_ACCELERATOR_HOVERED(3),
        BACKGROUND(4),
        BACKGROUND_HOVERED(5),
        COUNT(6)
        ;
        
        private int nativeInt;
        
        private MenuColorType(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:SslVersion).</em>
     * 
     * === Options:
     * CONNECTION_VERSION_UNKNOWN ::
     *   
     * CONNECTION_VERSION_SSL2 ::
     *   Unknown SSL version.
     * CONNECTION_VERSION_SSL3 ::
     *   
     * CONNECTION_VERSION_TLS1 ::
     *   
     * CONNECTION_VERSION_TLS1_1 ::
     *   
     * CONNECTION_VERSION_TLS1_2 ::
     *   
     * CONNECTION_VERSION_QUIC ::
     *   Reserve 6 for TLS 1.3.
     * 
     * @method _enum_SslVersion_
     * @return [Symbol]
     * @scope class
     */
    public enum SslVersion implements EnumMapper.IntegerEnum {
        CONNECTION_VERSION_UNKNOWN(0),
        CONNECTION_VERSION_SSL2(1),
        CONNECTION_VERSION_SSL3(2),
        CONNECTION_VERSION_TLS1(3),
        CONNECTION_VERSION_TLS1_1(4),
        CONNECTION_VERSION_TLS1_2(5),
        CONNECTION_VERSION_QUIC(7)
        ;
        
        private int nativeInt;
        
        private SslVersion(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:SslContentStatus).</em>
     * 
     * === Options:
     * NORMAL ::
     *   
     * DISPLAYED_INSECURE ::
     *   
     * RAN_INSECURE ::
     *   
     * 
     * @method _enum_SslContentStatus_
     * @return [Symbol]
     * @scope class
     */
    public enum SslContentStatus implements EnumMapper.IntegerEnum {
        NORMAL(0),
        DISPLAYED_INSECURE(1),
        RAN_INSECURE(2)
        ;
        
        private int nativeInt;
        
        private SslContentStatus(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:CdmRegistrationError).</em>
     * 
     * === Options:
     * NONE ::
     *   No error. Registration completed successfully.
     * INCORRECT_CONTENTS ::
     *   Required files or manifest contents are missing.
     * INCOMPATIBLE ::
     *   The CDM is incompatible with the current Chromium version.
     * NOT_SUPPORTED ::
     *   CDM registration is not supported at this time.
     * 
     * @method _enum_CdmRegistrationError_
     * @return [Symbol]
     * @scope class
     */
    public enum CdmRegistrationError implements EnumMapper.IntegerEnum {
        NONE(0),
        INCORRECT_CONTENTS(1),
        INCOMPATIBLE(2),
        NOT_SUPPORTED(3)
        ;
        
        private int nativeInt;
        
        private CdmRegistrationError(int nativeInt) {
            this.nativeInt = nativeInt;
        }
        
        @Override
        public int intValue() {
            return nativeInt;
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :range ::
     *   (Range) Underline character range.
     * :color ::
     *   (Integer) Text color.
     * :backgroundColor ::
     *   (Integer) Background color.
     * :thick ::
     *   (Integer) Set to true (1) for thick underline.
     */
    public static final class CompositionUnderline extends Struct {
        public Range range = inner(new Range(getRuntime()));
        public Unsigned32 color = new Unsigned32();
        public Unsigned32 backgroundColor = new Unsigned32();
        public Signed32 thick = new Signed32();
        public CompositionUnderline(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of the data structure.
     * :addRef ::
     *   (Function(AddRef)) Called to increment the reference count for the object. Should be called
     *   for every new copy of a pointer to a given object.
     * :release ::
     *   (Function(Release)) Called to decrement the reference count for the object. If the reference
     *   count falls to 0 the object should self-delete. Returns true (1) if the
     *   resulting reference count is 0.
     * :hasOneRef ::
     *   (Function(HasOneRef)) Returns true (1) if the current reference count is 1.
     */
    public static final class BaseRefCounted extends Struct {
        public UnsignedLong size = new UnsignedLong();
        public int ref = 1;
        java.lang.String name = "";

        public Function<AddRef> addRef = function(AddRef.class);
        public static interface AddRef {
            @Delegate
            void invoke(jnr.ffi.Pointer baseRefCounted);
        }
        public void setAddRef(AddRef callback) {
            addRef.set(callback);
        }
        
        public Function<Release> release = function(Release.class);
        public static interface Release {
            @Delegate
            int invoke(jnr.ffi.Pointer baseRefCounted);
        }
        public void setRelease(Release callback) {
            release.set(callback);
        }
        
        public Function<HasOneRef> hasOneRef = function(HasOneRef.class);
        public static interface HasOneRef {
            @Delegate
            int invoke(jnr.ffi.Pointer baseRefCounted);
        }
        public void setHasOneRef(HasOneRef callback) {
            hasOneRef.set(callback);
        }
        
        public BaseRefCounted(jnr.ffi.Runtime runtime) {
          super(runtime);
//          setFns();
//          directMemotyForStructReturn(this);
        }
        
		private void setFns() {
			setAddRef(new AddRefFN(this));
			setRelease(new ReleaseFN(this));
			setHasOneRef(new HasOneRefFN(this));
		}

		public void setSize(Struct client) {
			int sizeof = Struct.size(client);
			LOG.info("J:SIZEOF:" + client.getClass().getSimpleName() + ":" + sizeof);
			this.size.set(sizeof);
			this.name = client.getClass().getSimpleName();
		}
    }
    
    public static class AddRefFN implements BaseRefCounted.AddRef {
    	private BaseRefCounted base;

		public AddRefFN(BaseRefCounted base) {
			this.base = base;
		}

		@Override
    	public void invoke(jnr.ffi.Pointer self) {
    		base.ref++;
			//LOG.info("J:+ " + base.name + " ");
    		//ChromiumLog.log(base.ref);
    	}
    }
    // See https://bitbucket.org/chromiumembedded/cef/wiki/UsingTheCAPI.md
    public static class ReleaseFN implements BaseRefCounted.Release {
    	private BaseRefCounted base;

    	public ReleaseFN(BaseRefCounted base) {
			this.base = base;
		}

		@Override
    	public int invoke(jnr.ffi.Pointer self) {
    		base.ref--;
			//LOG.info("J:- " + base.name + " ");
    		//ChromiumLog.log(base.ref);
    		if (base.ref == 0) {
    			//TODO: free object using MemoryIO
    			LOG.info("J:"+ base.name + " Remove myself");
    		}
    		return (base.ref == 0) ? 1 : 0;
    	}
    }
    public static class HasOneRefFN implements BaseRefCounted.HasOneRef {
    	private BaseRefCounted base;

		public HasOneRefFN(BaseRefCounted base) {
			this.base = base;
		}

		@Override
    	public int invoke(jnr.ffi.Pointer self) {
			//LOG.info("J:= " + base.name + " ");
    		//ChromiumLog.log(base.ref);
    		return base.ref == 1 ? 1 : 0;
    	}
    }

    /**
     * (Not documented)
     * 
     * = Fields:
     * :size ::
     *   (Integer) Size of the data structure.
     * :del ::
     *   (Function(Del)) Called to delete this object. May be NULL if the object is not owned.
     */
    public static final class BaseScoped extends Struct {
        public UnsignedLong size = new UnsignedLong();
        public Function<Del> del = function(Del.class);
        public static interface Del {
            @Delegate
            void invoke(jnr.ffi.Pointer baseScoped);
        }
        public void setDel(Del callback) {
            del.set(callback);
        }
        
        public BaseScoped(jnr.ffi.Runtime runtime) {
          super(runtime);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :getHost ::
     *   (Function(GetHost)) Returns the browser host object. This function can only be called in the
     *   browser process.
     * :canGoBack ::
     *   (Function(CanGoBack)) Returns true (1) if the browser can navigate backwards.
     * :goBack ::
     *   (Function(GoBack)) Navigate backwards.
     * :canGoForward ::
     *   (Function(CanGoForward)) Returns true (1) if the browser can navigate forwards.
     * :goForward ::
     *   (Function(GoForward)) Navigate forwards.
     * :isLoading ::
     *   (Function(IsLoading)) Returns true (1) if the browser is currently loading.
     * :reload ::
     *   (Function(Reload)) Reload the current page.
     * :reloadIgnoreCache ::
     *   (Function(ReloadIgnoreCache)) Reload the current page ignoring any cached data.
     * :stopLoad ::
     *   (Function(StopLoad)) Stop loading the page.
     * :getIdentifier ::
     *   (Function(GetIdentifier)) Returns the globally unique identifier for this browser.
     * :isSame ::
     *   (Function(IsSame)) Returns true (1) if this object is pointing to the same handle as |that|
     *   object.
     * :isPopup ::
     *   (Function(IsPopup)) Returns true (1) if the window is a popup window.
     * :hasDocument ::
     *   (Function(HasDocument)) Returns true (1) if a document has been loaded in the browser.
     * :getMainFrame ::
     *   (Function(GetMainFrame)) Returns the main (top-level) frame for the browser window.
     * :getFocusedFrame ::
     *   (Function(GetFocusedFrame)) Returns the focused frame for the browser window.
     * :getFrameByident ::
     *   (Function(GetFrameByident)) Returns the frame with the specified identifier, or NULL if not found.
     * :getFrame ::
     *   (Function(GetFrame)) Returns the frame with the specified name, or NULL if not found.
     * :getFrameCount ::
     *   (Function(GetFrameCount)) Returns the number of frames that currently exist.
     * :getFrameIdentifiers ::
     *   (Function(GetFrameIdentifiers)) Returns the identifiers of all existing frames.
     * :getFrameNames ::
     *   (Function(GetFrameNames)) Returns the names of all existing frames.
     * :sendProcessMessage ::
     *   (Function(SendProcessMessage)) Send a message to the specified |target_process|. Returns true (1) if the
     *   message was sent successfully.
     */
    public static final class Browser extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<GetHost> getHost = function(GetHost.class);
        public static interface GetHost {
            @Delegate
            BrowserHost invoke(jnr.ffi.Pointer browser);
        }
        public void setGetHost(GetHost callback) {
            getHost.set(callback);
        }
        
        public Function<CanGoBack> canGoBack = function(CanGoBack.class);
        public static interface CanGoBack {
            @Delegate
            int invoke(jnr.ffi.Pointer browser);
        }
        public void setCanGoBack(CanGoBack callback) {
            canGoBack.set(callback);
        }
        
        public Function<GoBack> goBack = function(GoBack.class);
        public static interface GoBack {
            @Delegate
            void invoke(jnr.ffi.Pointer browser);
        }
        public void setGoBack(GoBack callback) {
            goBack.set(callback);
        }
        
        public Function<CanGoForward> canGoForward = function(CanGoForward.class);
        public static interface CanGoForward {
            @Delegate
            int invoke(jnr.ffi.Pointer browser);
        }
        public void setCanGoForward(CanGoForward callback) {
            canGoForward.set(callback);
        }
        
        public Function<GoForward> goForward = function(GoForward.class);
        public static interface GoForward {
            @Delegate
            void invoke(jnr.ffi.Pointer browser);
        }
        public void setGoForward(GoForward callback) {
            goForward.set(callback);
        }
        
        public Function<IsLoading> isLoading = function(IsLoading.class);
        public static interface IsLoading {
            @Delegate
            int invoke(jnr.ffi.Pointer browser);
        }
        public void setIsLoading(IsLoading callback) {
            isLoading.set(callback);
        }
        
        public Function<Reload> reload = function(Reload.class);
        public static interface Reload {
            @Delegate
            void invoke(jnr.ffi.Pointer browser);
        }
        public void setReload(Reload callback) {
            reload.set(callback);
        }
        
        public Function<ReloadIgnoreCache> reloadIgnoreCache = function(ReloadIgnoreCache.class);
        public static interface ReloadIgnoreCache {
            @Delegate
            void invoke(jnr.ffi.Pointer browser);
        }
        public void setReloadIgnoreCache(ReloadIgnoreCache callback) {
            reloadIgnoreCache.set(callback);
        }
        
        public Function<StopLoad> stopLoad = function(StopLoad.class);
        public static interface StopLoad {
            @Delegate
            void invoke(jnr.ffi.Pointer browser);
        }
        public void setStopLoad(StopLoad callback) {
            stopLoad.set(callback);
        }
        
        public Function<GetIdentifier> getIdentifier = function(GetIdentifier.class);
        public static interface GetIdentifier {
            @Delegate
            int invoke(jnr.ffi.Pointer browser);
        }
        public void setGetIdentifier(GetIdentifier callback) {
            getIdentifier.set(callback);
        }
        
        public Function<IsSame> isSame = function(IsSame.class);
        public static interface IsSame {
            @Delegate
            int invoke(jnr.ffi.Pointer browser, jnr.ffi.Pointer browser_1);
        }
        public void setIsSame(IsSame callback) {
            isSame.set(callback);
        }
        
        public Function<IsPopup> isPopup = function(IsPopup.class);
        public static interface IsPopup {
            @Delegate
            int invoke(jnr.ffi.Pointer browser);
        }
        public void setIsPopup(IsPopup callback) {
            isPopup.set(callback);
        }
        
        public Function<HasDocument> hasDocument = function(HasDocument.class);
        public static interface HasDocument {
            @Delegate
            int invoke(jnr.ffi.Pointer browser);
        }
        public void setHasDocument(HasDocument callback) {
            hasDocument.set(callback);
        }
        
        public Function<GetMainFrame> getMainFrame = function(GetMainFrame.class);
        public static interface GetMainFrame {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer browser);
        }
        public void setGetMainFrame(GetMainFrame callback) {
            getMainFrame.set(callback);
        }
        
        public Function<GetFocusedFrame> getFocusedFrame = function(GetFocusedFrame.class);
        public static interface GetFocusedFrame {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer browser);
        }
        public void setGetFocusedFrame(GetFocusedFrame callback) {
            getFocusedFrame.set(callback);
        }
        
        public Function<GetFrameByident> getFrameByident = function(GetFrameByident.class);
        public static interface GetFrameByident {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer browser, long long_1);
        }
        public void setGetFrameByident(GetFrameByident callback) {
            getFrameByident.set(callback);
        }
        
        public Function<GetFrame> getFrame = function(GetFrame.class);
        public static interface GetFrame {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer browser, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setGetFrame(GetFrame callback) {
            getFrame.set(callback);
        }
        
        public Function<GetFrameCount> getFrameCount = function(GetFrameCount.class);
        public static interface GetFrameCount {
            @Delegate
            long invoke(jnr.ffi.Pointer browser);
        }
        public void setGetFrameCount(GetFrameCount callback) {
            getFrameCount.set(callback);
        }
        
        public Function<GetFrameIdentifiers> getFrameIdentifiers = function(GetFrameIdentifiers.class);
        public static interface GetFrameIdentifiers {
            @Delegate
            void invoke(jnr.ffi.Pointer browser, jnr.ffi.Pointer uLong_1, jnr.ffi.Pointer long_2);
        }
        public void setGetFrameIdentifiers(GetFrameIdentifiers callback) {
            getFrameIdentifiers.set(callback);
        }
        
        public Function<GetFrameNames> getFrameNames = function(GetFrameNames.class);
        public static interface GetFrameNames {
            @Delegate
            void invoke(jnr.ffi.Pointer browser, jnr.ffi.Pointer void_1);
        }
        public void setGetFrameNames(GetFrameNames callback) {
            getFrameNames.set(callback);
        }
        
        public Function<SendProcessMessage> sendProcessMessage = function(SendProcessMessage.class);
        public static interface SendProcessMessage {
            @Delegate
            int invoke(jnr.ffi.Pointer browser, ProcessId processId_1, jnr.ffi.Pointer processMessage_2);
        }
        public void setSendProcessMessage(SendProcessMessage callback) {
            sendProcessMessage.set(callback);
        }
        
        public Browser(jnr.ffi.Runtime runtime) {
          super(runtime);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :onFileDialogDismissed ::
     *   (Function(OnFileDialogDismissed)) Called asynchronously after the file dialog is dismissed.
     *   |selected_accept_filter| is the 0-based index of the value selected from
     *   the accept filters array passed to cef_browser_host_t::RunFileDialog.
     *   |file_paths| will be a single value or a list of values depending on the
     *   dialog mode. If the selection was cancelled |file_paths| will be NULL.
     */
    public static final class RunFileDialogCallback extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<OnFileDialogDismissed> onFileDialogDismissed = function(OnFileDialogDismissed.class);
        public static interface OnFileDialogDismissed {
            @Delegate
            void invoke(jnr.ffi.Pointer runFileDialogCallback, int int_1, jnr.ffi.Pointer void_2);
        }
        public void setOnFileDialogDismissed(OnFileDialogDismissed callback) {
            onFileDialogDismissed.set(callback);
        }
        
        public RunFileDialogCallback(jnr.ffi.Runtime runtime) {
          super(runtime);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :visit ::
     *   (Function(Visit)) Method that will be executed. Do not keep a reference to |entry| outside of
     *   this callback. Return true (1) to continue visiting entries or false (0) to
     *   stop. |current| is true (1) if this entry is the currently loaded
     *   navigation entry. |index| is the 0-based index of this entry and |total| is
     *   the total number of entries.
     */
    public static final class NavigationEntryVisitor extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<Visit> visit = function(Visit.class);
        public static interface Visit {
            @Delegate
            int invoke(jnr.ffi.Pointer navigationEntryVisitor, jnr.ffi.Pointer navigationEntry_1, int int_2, int int_3, int int_4);
        }
        public void setVisit(Visit callback) {
            visit.set(callback);
        }
        
        public NavigationEntryVisitor(jnr.ffi.Runtime runtime) {
          super(runtime);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :onPdfPrintFinished ::
     *   (Function(OnPdfPrintFinished)) Method that will be executed when the PDF printing has completed. |path| is
     *   the output path. |ok| will be true (1) if the printing completed
     *   successfully or false (0) otherwise.
     */
    public static final class PdfPrintCallback extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<OnPdfPrintFinished> onPdfPrintFinished = function(OnPdfPrintFinished.class);
        public static interface OnPdfPrintFinished {
            @Delegate
            void invoke(jnr.ffi.Pointer pdfPrintCallback, jnr.ffi.Pointer stringUtf16_1, int int_2);
        }
        public void setOnPdfPrintFinished(OnPdfPrintFinished callback) {
            onPdfPrintFinished.set(callback);
        }
        
        public PdfPrintCallback(jnr.ffi.Runtime runtime) {
          super(runtime);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :onDownloadImageFinished ::
     *   (Function(OnDownloadImageFinished)) Method that will be executed when the image download has completed.
     *   |image_url| is the URL that was downloaded and |http_status_code| is the
     *   resulting HTTP status code. |image| is the resulting image, possibly at
     *   multiple scale factors, or NULL if the download failed.
     */
    public static final class DownloadImageCallback extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<OnDownloadImageFinished> onDownloadImageFinished = function(OnDownloadImageFinished.class);
        public static interface OnDownloadImageFinished {
            @Delegate
            void invoke(jnr.ffi.Pointer downloadImageCallback, jnr.ffi.Pointer stringUtf16_1, int int_2, jnr.ffi.Pointer image_3);
        }
        public void setOnDownloadImageFinished(OnDownloadImageFinished callback) {
            onDownloadImageFinished.set(callback);
        }
        
        public DownloadImageCallback(jnr.ffi.Runtime runtime) {
          super(runtime);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :getBrowser ::
     *   (Function(GetBrowser)) Returns the hosted browser object.
     * :closeBrowser ::
     *   (Function(CloseBrowser)) Request that the browser close. The JavaScript 'onbeforeunload' event will
     *   be fired. If |force_close| is false (0) the event handler, if any, will be
     *   allowed to prompt the user and the user can optionally cancel the close. If
     *   |force_close| is true (1) the prompt will not be displayed and the close
     *   will proceed. Results in a call to cef_life_span_handler_t::do_close() if
     *   the event handler allows the close or if |force_close| is true (1). See
     *   cef_life_span_handler_t::do_close() documentation for additional usage
     *   information.
     * :tryCloseBrowser ::
     *   (Function(TryCloseBrowser)) Helper for closing a browser. Call this function from the top-level window
     *   close handler. Internally this calls CloseBrowser(false (0)) if the close
     *   has not yet been initiated. This function returns false (0) while the close
     *   is pending and true (1) after the close has completed. See close_browser()
     *   and cef_life_span_handler_t::do_close() documentation for additional usage
     *   information. This function must be called on the browser process UI thread.
     * :setFocus ::
     *   (Function(SetFocus)) Set whether the browser is focused.
     * :getWindowHandle ::
     *   (Function(GetWindowHandle)) 
     * :getOpenerWindowHandle ::
     *   (Function(GetOpenerWindowHandle)) 
     * :hasView ::
     *   (Function(HasView)) Returns true (1) if this browser is wrapped in a cef_browser_view_t.
     * :getClient ::
     *   (Function(GetClient)) Returns the client for this browser.
     * :getRequestContext ::
     *   (Function(GetRequestContext)) Returns the request context for this browser.
     * :getZoomLevel ::
     *   (Function(GetZoomLevel)) Get the current zoom level. The default zoom level is 0.0. This function
     *   can only be called on the UI thread.
     * :setZoomLevel ::
     *   (Function(SetZoomLevel)) Change the zoom level to the specified value. Specify 0.0 to reset the zoom
     *   level. If called on the UI thread the change will be applied immediately.
     *   Otherwise, the change will be applied asynchronously on the UI thread.
     * :runFileDialog ::
     *   (Function(RunFileDialog)) Call to run a file chooser dialog. Only a single file chooser dialog may be
     *   pending at any given time. |mode| represents the type of dialog to display.
     *   |title| to the title to be used for the dialog and may be NULL to show the
     *   default title ("Open" or "Save" depending on the mode). |default_file_path|
     *   is the path with optional directory and/or file name component that will be
     *   initially selected in the dialog. |accept_filters| are used to restrict the
     *   selectable file types and may any combination of (a) valid lower-cased MIME
     *   types (e.g. "text/*" or "image/*"), (b) individual file extensions (e.g.
     *   ".txt" or ".png"), or (c) combined description and file extension delimited
     *   using "|" and ";" (e.g. "Image Types|.png;.gif;.jpg").
     *   |selected_accept_filter| is the 0-based index of the filter that will be
     *   selected by default. |callback| will be executed after the dialog is
     *   dismissed or immediately if another dialog is already pending. The dialog
     *   will be initiated asynchronously on the UI thread.
     * :startDownload ::
     *   (Function(StartDownload)) Download the file at |url| using cef_download_handler_t.
     * :downloadImage ::
     *   (Function(DownloadImage)) Download |image_url| and execute |callback| on completion with the images
     *   received from the renderer. If |is_favicon| is true (1) then cookies are
     *   not sent and not accepted during download. Images with density independent
     *   pixel (DIP) sizes larger than |max_image_size| are filtered out from the
     *   image results. Versions of the image at different scale factors may be
     *   downloaded up to the maximum scale factor supported by the system. If there
     *   are no image results <= |max_image_size| then the smallest image is resized
     *   to |max_image_size| and is the only result. A |max_image_size| of 0 means
     *   unlimited. If |bypass_cache| is true (1) then |image_url| is requested from
     *   the server even if it is present in the browser cache.
     * :print ::
     *   (Function(Print)) Print the current browser contents.
     * :printToPdf ::
     *   (Function(PrintToPdf)) Print the current browser contents to the PDF file specified by |path| and
     *   execute |callback| on completion. The caller is responsible for deleting
     *   |path| when done. For PDF printing to work on Linux you must implement the
     *   cef_print_handler_t::GetPdfPaperSize function.
     * :find ::
     *   (Function(Find)) Search for |searchText|. |identifier| can be used to have multiple searches
     *   running simultaniously. |forward| indicates whether to search forward or
     *   backward within the page. |matchCase| indicates whether the search should
     *   be case-sensitive. |findNext| indicates whether this is the first request
     *   or a follow-up. The cef_find_handler_t instance, if any, returned via
     *   cef_client_t::GetFindHandler will be called to report find results.
     * :stopFinding ::
     *   (Function(StopFinding)) Cancel all searches that are currently going on.
     * :showDevTools ::
     *   (Function(ShowDevTools)) Open developer tools (DevTools) in its own browser. The DevTools browser
     *   will remain associated with this browser. If the DevTools browser is
     *   already open then it will be focused, in which case the |windowInfo|,
     *   |client| and |settings| parameters will be ignored. If |inspect_element_at|
     *   is non-NULL then the element at the specified (x,y) location will be
     *   inspected. The |windowInfo| parameter will be ignored if this browser is
     *   wrapped in a cef_browser_view_t.
     * :closeDevTools ::
     *   (Function(CloseDevTools)) Explicitly close the associated DevTools browser, if any.
     * :hasDevTools ::
     *   (Function(HasDevTools)) Returns true (1) if this browser currently has an associated DevTools
     *   browser. Must be called on the browser process UI thread.
     * :getNavigationEntries ::
     *   (Function(GetNavigationEntries)) Retrieve a snapshot of current navigation entries as values sent to the
     *   specified visitor. If |current_only| is true (1) only the current
     *   navigation entry will be sent, otherwise all navigation entries will be
     *   sent.
     * :setMouseCursorChangeDisabled ::
     *   (Function(SetMouseCursorChangeDisabled)) Set whether mouse cursor change is disabled.
     * :isMouseCursorChangeDisabled ::
     *   (Function(IsMouseCursorChangeDisabled)) Returns true (1) if mouse cursor change is disabled.
     * :replaceMisspelling ::
     *   (Function(ReplaceMisspelling)) If a misspelled word is currently selected in an editable node calling this
     *   function will replace it with the specified |word|.
     * :addWordToDictionary ::
     *   (Function(AddWordToDictionary)) Add the specified |word| to the spelling dictionary.
     * :isWindowRenderingDisabled ::
     *   (Function(IsWindowRenderingDisabled)) Returns true (1) if window rendering is disabled.
     * :wasResized ::
     *   (Function(WasResized)) Notify the browser that the widget has been resized. The browser will first
     *   call cef_render_handler_t::GetViewRect to get the new size and then call
     *   cef_render_handler_t::OnPaint asynchronously with the updated regions. This
     *   function is only used when window rendering is disabled.
     * :wasHidden ::
     *   (Function(WasHidden)) Notify the browser that it has been hidden or shown. Layouting and
     *   cef_render_handler_t::OnPaint notification will stop when the browser is
     *   hidden. This function is only used when window rendering is disabled.
     * :notifyScreenInfoChanged ::
     *   (Function(NotifyScreenInfoChanged)) Send a notification to the browser that the screen info has changed. The
     *   browser will then call cef_render_handler_t::GetScreenInfo to update the
     *   screen information with the new values. This simulates moving the webview
     *   window from one display to another, or changing the properties of the
     *   current display. This function is only used when window rendering is
     *   disabled.
     * :invalidate ::
     *   (Function(Invalidate)) Invalidate the view. The browser will call cef_render_handler_t::OnPaint
     *   asynchronously. This function is only used when window rendering is
     *   disabled.
     * :sendKeyEvent ::
     *   (Function(SendKeyEvent)) Send a key event to the browser.
     * :sendMouseClickEvent ::
     *   (Function(SendMouseClickEvent)) Send a mouse click event to the browser. The |x| and |y| coordinates are
     *   relative to the upper-left corner of the view.
     * :sendMouseMoveEvent ::
     *   (Function(SendMouseMoveEvent)) Send a mouse move event to the browser. The |x| and |y| coordinates are
     *   relative to the upper-left corner of the view.
     * :sendMouseWheelEvent ::
     *   (Function(SendMouseWheelEvent)) Send a mouse wheel event to the browser. The |x| and |y| coordinates are
     *   relative to the upper-left corner of the view. The |deltaX| and |deltaY|
     *   values represent the movement delta in the X and Y directions respectively.
     *   In order to scroll inside select popups with window rendering disabled
     *   cef_render_handler_t::GetScreenPoint should be implemented properly.
     * :sendFocusEvent ::
     *   (Function(SendFocusEvent)) Send a focus event to the browser.
     * :sendCaptureLostEvent ::
     *   (Function(SendCaptureLostEvent)) Send a capture lost event to the browser.
     * :notifyMoveOrResizeStarted ::
     *   (Function(NotifyMoveOrResizeStarted)) Notify the browser that the window hosting it is about to be moved or
     *   resized. This function is only used on Windows and Linux.
     * :getWindowlessFrameRate ::
     *   (Function(GetWindowlessFrameRate)) Returns the maximum rate in frames per second (fps) that
     *   cef_render_handler_t:: OnPaint will be called for a windowless browser. The
     *   actual fps may be lower if the browser cannot generate frames at the
     *   requested rate. The minimum value is 1 and the maximum value is 60 (default
     *   30). This function can only be called on the UI thread.
     * :setWindowlessFrameRate ::
     *   (Function(SetWindowlessFrameRate)) Set the maximum rate in frames per second (fps) that cef_render_handler_t::
     *   OnPaint will be called for a windowless browser. The actual fps may be
     *   lower if the browser cannot generate frames at the requested rate. The
     *   minimum value is 1 and the maximum value is 60 (default 30). Can also be
     *   set at browser creation via cef_browser_tSettings.windowless_frame_rate.
     * :imeSetComposition ::
     *   (Function(ImeSetComposition)) Begins a new composition or updates the existing composition. Blink has a
     *   special node (a composition node) that allows the input function to change
     *   text without affecting other DOM nodes. |text| is the optional text that
     *   will be inserted into the composition node. |underlines| is an optional set
     *   of ranges that will be underlined in the resulting text.
     *   |replacement_range| is an optional range of the existing text that will be
     *   replaced. |selection_range| is an optional range of the resulting text that
     *   will be selected after insertion or replacement. The |replacement_range|
     *   value is only used on OS X.
     *   
     *   This function may be called multiple times as the composition changes. When
     *   the client is done making changes the composition should either be canceled
     *   or completed. To cancel the composition call ImeCancelComposition. To
     *   complete the composition call either ImeCommitText or
     *   ImeFinishComposingText. Completion is usually signaled when:
     *     A. The client receives a WM_IME_COMPOSITION message with a GCS_RESULTSTR
     *        flag (on Windows), or;
     *     B. The client receives a "commit" signal of GtkIMContext (on Linux), or;
     *     C. insertText of NSTextInput is called (on Mac).
     *   
     *   This function is only used when window rendering is disabled.
     * :imeCommitText ::
     *   (Function(ImeCommitText)) Completes the existing composition by optionally inserting the specified
     *   |text| into the composition node. |replacement_range| is an optional range
     *   of the existing text that will be replaced. |relative_cursor_pos| is where
     *   the cursor will be positioned relative to the current cursor position. See
     *   comments on ImeSetComposition for usage. The |replacement_range| and
     *   |relative_cursor_pos| values are only used on OS X. This function is only
     *   used when window rendering is disabled.
     * :imeFinishComposingText ::
     *   (Function(ImeFinishComposingText)) Completes the existing composition by applying the current composition node
     *   contents. If |keep_selection| is false (0) the current selection, if any,
     *   will be discarded. See comments on ImeSetComposition for usage. This
     *   function is only used when window rendering is disabled.
     * :imeCancelComposition ::
     *   (Function(ImeCancelComposition)) Cancels the existing composition and discards the composition node contents
     *   without applying them. See comments on ImeSetComposition for usage. This
     *   function is only used when window rendering is disabled.
     * :dragTargetDragEnter ::
     *   (Function(DragTargetDragEnter)) Call this function when the user drags the mouse into the web view (before
     *   calling DragTargetDragOver/DragTargetLeave/DragTargetDrop). |drag_data|
     *   should not contain file contents as this type of data is not allowed to be
     *   dragged into the web view. File contents can be removed using
     *   cef_drag_data_t::ResetFileContents (for example, if |drag_data| comes from
     *   cef_render_handler_t::StartDragging). This function is only used when
     *   window rendering is disabled.
     * :dragTargetDragOver ::
     *   (Function(DragTargetDragOver)) Call this function each time the mouse is moved across the web view during
     *   a drag operation (after calling DragTargetDragEnter and before calling
     *   DragTargetDragLeave/DragTargetDrop). This function is only used when window
     *   rendering is disabled.
     * :dragTargetDragLeave ::
     *   (Function(DragTargetDragLeave)) Call this function when the user drags the mouse out of the web view (after
     *   calling DragTargetDragEnter). This function is only used when window
     *   rendering is disabled.
     * :dragTargetDrop ::
     *   (Function(DragTargetDrop)) Call this function when the user completes the drag operation by dropping
     *   the object onto the web view (after calling DragTargetDragEnter). The
     *   object being dropped is |drag_data|, given as an argument to the previous
     *   DragTargetDragEnter call. This function is only used when window rendering
     *   is disabled.
     * :dragSourceEndedAt ::
     *   (Function(DragSourceEndedAt)) Call this function when the drag operation started by a
     *   cef_render_handler_t::StartDragging call has ended either in a drop or by
     *   being cancelled. |x| and |y| are mouse coordinates relative to the upper-
     *   left corner of the view. If the web view is both the drag source and the
     *   drag target then all DragTarget* functions should be called before
     *   DragSource* mthods. This function is only used when window rendering is
     *   disabled.
     * :dragSourceSystemDragEnded ::
     *   (Function(DragSourceSystemDragEnded)) Call this function when the drag operation started by a
     *   cef_render_handler_t::StartDragging call has completed. This function may
     *   be called immediately without first calling DragSourceEndedAt to cancel a
     *   drag operation. If the web view is both the drag source and the drag target
     *   then all DragTarget* functions should be called before DragSource* mthods.
     *   This function is only used when window rendering is disabled.
     * :getVisibleNavigationEntry ::
     *   (Function(GetVisibleNavigationEntry)) Returns the current visible navigation entry for this browser. This
     *   function can only be called on the UI thread.
     */
    public static final class BrowserHost extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<GetBrowser> getBrowser = function(GetBrowser.class);
        public static interface GetBrowser {
            @Delegate
            Browser invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetBrowser(GetBrowser callback) {
            getBrowser.set(callback);
        }
        
        public Function<CloseBrowser> closeBrowser = function(CloseBrowser.class);
        public static interface CloseBrowser {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setCloseBrowser(CloseBrowser callback) {
            closeBrowser.set(callback);
        }
        
        public Function<TryCloseBrowser> tryCloseBrowser = function(TryCloseBrowser.class);
        public static interface TryCloseBrowser {
            @Delegate
            int invoke(jnr.ffi.Pointer browserHost);
        }
        public void setTryCloseBrowser(TryCloseBrowser callback) {
            tryCloseBrowser.set(callback);
        }
        
        public Function<SetFocus> setFocus = function(SetFocus.class);
        public static interface SetFocus {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setSetFocus(SetFocus callback) {
            setFocus.set(callback);
        }
        
        public Function<GetWindowHandle> getWindowHandle = function(GetWindowHandle.class);
        public static interface GetWindowHandle {
            @Delegate
            long invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetWindowHandle(GetWindowHandle callback) {
            getWindowHandle.set(callback);
        }
        
        public Function<GetOpenerWindowHandle> getOpenerWindowHandle = function(GetOpenerWindowHandle.class);
        public static interface GetOpenerWindowHandle {
            @Delegate
            long invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetOpenerWindowHandle(GetOpenerWindowHandle callback) {
            getOpenerWindowHandle.set(callback);
        }
        
        public Function<HasView> hasView = function(HasView.class);
        public static interface HasView {
            @Delegate
            int invoke(jnr.ffi.Pointer browserHost);
        }
        public void setHasView(HasView callback) {
            hasView.set(callback);
        }
        
        public Function<GetClient> getClient = function(GetClient.class);
        public static interface GetClient {
            @Delegate
            Client invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetClient(GetClient callback) {
            getClient.set(callback);
        }
        
        public Function<GetRequestContext> getRequestContext = function(GetRequestContext.class);
        public static interface GetRequestContext {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetRequestContext(GetRequestContext callback) {
            getRequestContext.set(callback);
        }
        
        public Function<GetZoomLevel> getZoomLevel = function(GetZoomLevel.class);
        public static interface GetZoomLevel {
            @Delegate
            double invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetZoomLevel(GetZoomLevel callback) {
            getZoomLevel.set(callback);
        }
        
        public Function<SetZoomLevel> setZoomLevel = function(SetZoomLevel.class);
        public static interface SetZoomLevel {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, double double_1);
        }
        public void setSetZoomLevel(SetZoomLevel callback) {
            setZoomLevel.set(callback);
        }
        
        public Function<RunFileDialog> runFileDialog = function(RunFileDialog.class);
        public static interface RunFileDialog {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, FileDialogMode fileDialogMode_1, jnr.ffi.Pointer stringUtf16_2, jnr.ffi.Pointer stringUtf16_3, jnr.ffi.Pointer void_4, int int_5, jnr.ffi.Pointer runFileDialogCallback_6);
        }
        public void setRunFileDialog(RunFileDialog callback) {
            runFileDialog.set(callback);
        }
        
        public Function<StartDownload> startDownload = function(StartDownload.class);
        public static interface StartDownload {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setStartDownload(StartDownload callback) {
            startDownload.set(callback);
        }
        
        public Function<DownloadImage> downloadImage = function(DownloadImage.class);
        public static interface DownloadImage {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer stringUtf16_1, int int_2, int u_int_3, int int_4, jnr.ffi.Pointer downloadImageCallback_5);
        }
        public void setDownloadImage(DownloadImage callback) {
            downloadImage.set(callback);
        }
        
        public Function<Print> print = function(Print.class);
        public static interface Print {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setPrint(Print callback) {
            print.set(callback);
        }
        
        public Function<PrintToPdf> printToPdf = function(PrintToPdf.class);
        public static interface PrintToPdf {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer stringUtf16_1, jnr.ffi.Pointer pdfPrintSettings_2, jnr.ffi.Pointer pdfPrintCallback_3);
        }
        public void setPrintToPdf(PrintToPdf callback) {
            printToPdf.set(callback);
        }
        
        public Function<Find> find = function(Find.class);
        public static interface Find {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1, jnr.ffi.Pointer stringUtf16_2, int int_3, int int_4, int int_5);
        }
        public void setFind(Find callback) {
            find.set(callback);
        }
        
        public Function<StopFinding> stopFinding = function(StopFinding.class);
        public static interface StopFinding {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setStopFinding(StopFinding callback) {
            stopFinding.set(callback);
        }
        
        public Function<ShowDevTools> showDevTools = function(ShowDevTools.class);
        public static interface ShowDevTools {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer windowInfo_1, jnr.ffi.Pointer client_2, jnr.ffi.Pointer browserSettings_3, jnr.ffi.Pointer point_4);
        }
        public void setShowDevTools(ShowDevTools callback) {
            showDevTools.set(callback);
        }
        
        public Function<CloseDevTools> closeDevTools = function(CloseDevTools.class);
        public static interface CloseDevTools {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setCloseDevTools(CloseDevTools callback) {
            closeDevTools.set(callback);
        }
        
        public Function<HasDevTools> hasDevTools = function(HasDevTools.class);
        public static interface HasDevTools {
            @Delegate
            int invoke(jnr.ffi.Pointer browserHost);
        }
        public void setHasDevTools(HasDevTools callback) {
            hasDevTools.set(callback);
        }
        
        public Function<GetNavigationEntries> getNavigationEntries = function(GetNavigationEntries.class);
        public static interface GetNavigationEntries {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer navigationEntryVisitor_1, int int_2);
        }
        public void setGetNavigationEntries(GetNavigationEntries callback) {
            getNavigationEntries.set(callback);
        }
        
        public Function<SetMouseCursorChangeDisabled> setMouseCursorChangeDisabled = function(SetMouseCursorChangeDisabled.class);
        public static interface SetMouseCursorChangeDisabled {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setSetMouseCursorChangeDisabled(SetMouseCursorChangeDisabled callback) {
            setMouseCursorChangeDisabled.set(callback);
        }
        
        public Function<IsMouseCursorChangeDisabled> isMouseCursorChangeDisabled = function(IsMouseCursorChangeDisabled.class);
        public static interface IsMouseCursorChangeDisabled {
            @Delegate
            int invoke(jnr.ffi.Pointer browserHost);
        }
        public void setIsMouseCursorChangeDisabled(IsMouseCursorChangeDisabled callback) {
            isMouseCursorChangeDisabled.set(callback);
        }
        
        public Function<ReplaceMisspelling> replaceMisspelling = function(ReplaceMisspelling.class);
        public static interface ReplaceMisspelling {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setReplaceMisspelling(ReplaceMisspelling callback) {
            replaceMisspelling.set(callback);
        }
        
        public Function<AddWordToDictionary> addWordToDictionary = function(AddWordToDictionary.class);
        public static interface AddWordToDictionary {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setAddWordToDictionary(AddWordToDictionary callback) {
            addWordToDictionary.set(callback);
        }
        
        public Function<IsWindowRenderingDisabled> isWindowRenderingDisabled = function(IsWindowRenderingDisabled.class);
        public static interface IsWindowRenderingDisabled {
            @Delegate
            int invoke(jnr.ffi.Pointer browserHost);
        }
        public void setIsWindowRenderingDisabled(IsWindowRenderingDisabled callback) {
            isWindowRenderingDisabled.set(callback);
        }
        
        public Function<WasResized> wasResized = function(WasResized.class);
        public static interface WasResized {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setWasResized(WasResized callback) {
            wasResized.set(callback);
        }
        
        public Function<WasHidden> wasHidden = function(WasHidden.class);
        public static interface WasHidden {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setWasHidden(WasHidden callback) {
            wasHidden.set(callback);
        }
        
        public Function<NotifyScreenInfoChanged> notifyScreenInfoChanged = function(NotifyScreenInfoChanged.class);
        public static interface NotifyScreenInfoChanged {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setNotifyScreenInfoChanged(NotifyScreenInfoChanged callback) {
            notifyScreenInfoChanged.set(callback);
        }
        
        public Function<Invalidate> invalidate = function(Invalidate.class);
        public static interface Invalidate {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, PaintElementType paintElementType_1);
        }
        public void setInvalidate(Invalidate callback) {
            invalidate.set(callback);
        }
        
        public Function<SendKeyEvent> sendKeyEvent = function(SendKeyEvent.class);
        public static interface SendKeyEvent {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer keyEvent_1);
        }
        public void setSendKeyEvent(SendKeyEvent callback) {
            sendKeyEvent.set(callback);
        }
        
        public Function<SendMouseClickEvent> sendMouseClickEvent = function(SendMouseClickEvent.class);
        public static interface SendMouseClickEvent {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer mouseEvent_1, MouseButtonType mouseButtonType_2, int int_3, int int_4);
        }
        public void setSendMouseClickEvent(SendMouseClickEvent callback) {
            sendMouseClickEvent.set(callback);
        }
        
        public Function<SendMouseMoveEvent> sendMouseMoveEvent = function(SendMouseMoveEvent.class);
        public static interface SendMouseMoveEvent {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer mouseEvent_1, int int_2);
        }
        public void setSendMouseMoveEvent(SendMouseMoveEvent callback) {
            sendMouseMoveEvent.set(callback);
        }
        
        public Function<SendMouseWheelEvent> sendMouseWheelEvent = function(SendMouseWheelEvent.class);
        public static interface SendMouseWheelEvent {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer mouseEvent_1, int int_2, int int_3);
        }
        public void setSendMouseWheelEvent(SendMouseWheelEvent callback) {
            sendMouseWheelEvent.set(callback);
        }
        
        public Function<SendFocusEvent> sendFocusEvent = function(SendFocusEvent.class);
        public static interface SendFocusEvent {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setSendFocusEvent(SendFocusEvent callback) {
            sendFocusEvent.set(callback);
        }
        
        public Function<SendCaptureLostEvent> sendCaptureLostEvent = function(SendCaptureLostEvent.class);
        public static interface SendCaptureLostEvent {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setSendCaptureLostEvent(SendCaptureLostEvent callback) {
            sendCaptureLostEvent.set(callback);
        }
        
        public Function<NotifyMoveOrResizeStarted> notifyMoveOrResizeStarted = function(NotifyMoveOrResizeStarted.class);
        public static interface NotifyMoveOrResizeStarted {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setNotifyMoveOrResizeStarted(NotifyMoveOrResizeStarted callback) {
            notifyMoveOrResizeStarted.set(callback);
        }
        
        public Function<GetWindowlessFrameRate> getWindowlessFrameRate = function(GetWindowlessFrameRate.class);
        public static interface GetWindowlessFrameRate {
            @Delegate
            int invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetWindowlessFrameRate(GetWindowlessFrameRate callback) {
            getWindowlessFrameRate.set(callback);
        }
        
        public Function<SetWindowlessFrameRate> setWindowlessFrameRate = function(SetWindowlessFrameRate.class);
        public static interface SetWindowlessFrameRate {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setSetWindowlessFrameRate(SetWindowlessFrameRate callback) {
            setWindowlessFrameRate.set(callback);
        }
        
        public Function<ImeSetComposition> imeSetComposition = function(ImeSetComposition.class);
        public static interface ImeSetComposition {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer stringUtf16_1, long u_long_2, jnr.ffi.Pointer compositionUnderline_3, jnr.ffi.Pointer range_4, jnr.ffi.Pointer range_5);
        }
        public void setImeSetComposition(ImeSetComposition callback) {
            imeSetComposition.set(callback);
        }
        
        public Function<ImeCommitText> imeCommitText = function(ImeCommitText.class);
        public static interface ImeCommitText {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer stringUtf16_1, jnr.ffi.Pointer range_2, int int_3);
        }
        public void setImeCommitText(ImeCommitText callback) {
            imeCommitText.set(callback);
        }
        
        public Function<ImeFinishComposingText> imeFinishComposingText = function(ImeFinishComposingText.class);
        public static interface ImeFinishComposingText {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1);
        }
        public void setImeFinishComposingText(ImeFinishComposingText callback) {
            imeFinishComposingText.set(callback);
        }
        
        public Function<ImeCancelComposition> imeCancelComposition = function(ImeCancelComposition.class);
        public static interface ImeCancelComposition {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setImeCancelComposition(ImeCancelComposition callback) {
            imeCancelComposition.set(callback);
        }
        
        public Function<DragTargetDragEnter> dragTargetDragEnter = function(DragTargetDragEnter.class);
        public static interface DragTargetDragEnter {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer dragData_1, jnr.ffi.Pointer mouseEvent_2, DragOperationsMask dragOperationsMask_3);
        }
        public void setDragTargetDragEnter(DragTargetDragEnter callback) {
            dragTargetDragEnter.set(callback);
        }
        
        public Function<DragTargetDragOver> dragTargetDragOver = function(DragTargetDragOver.class);
        public static interface DragTargetDragOver {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer mouseEvent_1, DragOperationsMask dragOperationsMask_2);
        }
        public void setDragTargetDragOver(DragTargetDragOver callback) {
            dragTargetDragOver.set(callback);
        }
        
        public Function<DragTargetDragLeave> dragTargetDragLeave = function(DragTargetDragLeave.class);
        public static interface DragTargetDragLeave {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setDragTargetDragLeave(DragTargetDragLeave callback) {
            dragTargetDragLeave.set(callback);
        }
        
        public Function<DragTargetDrop> dragTargetDrop = function(DragTargetDrop.class);
        public static interface DragTargetDrop {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, jnr.ffi.Pointer mouseEvent_1);
        }
        public void setDragTargetDrop(DragTargetDrop callback) {
            dragTargetDrop.set(callback);
        }
        
        public Function<DragSourceEndedAt> dragSourceEndedAt = function(DragSourceEndedAt.class);
        public static interface DragSourceEndedAt {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost, int int_1, int int_2, DragOperationsMask dragOperationsMask_3);
        }
        public void setDragSourceEndedAt(DragSourceEndedAt callback) {
            dragSourceEndedAt.set(callback);
        }
        
        public Function<DragSourceSystemDragEnded> dragSourceSystemDragEnded = function(DragSourceSystemDragEnded.class);
        public static interface DragSourceSystemDragEnded {
            @Delegate
            void invoke(jnr.ffi.Pointer browserHost);
        }
        public void setDragSourceSystemDragEnded(DragSourceSystemDragEnded callback) {
            dragSourceSystemDragEnded.set(callback);
        }
        
        public Function<GetVisibleNavigationEntry> getVisibleNavigationEntry = function(GetVisibleNavigationEntry.class);
        public static interface GetVisibleNavigationEntry {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer browserHost);
        }
        public void setGetVisibleNavigationEntry(GetVisibleNavigationEntry callback) {
            getVisibleNavigationEntry.set(callback);
        }
        
        public BrowserHost(jnr.ffi.Runtime runtime) {
          super(runtime);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * @method browserHostCreateBrowser(windowInfo, client, url, settings, requestContext)
     * @param [WindowInfo] windowInfo 
     * @param [FFI::Pointer(*Client)] client 
     * @param [StringUtf16] url 
     * @param [BrowserSettings] settings 
     * @param [FFI::Pointer(*RequestContext)] requestContext 
     * @return [Integer] 
     * @scope class
     */
    public static int browserHostCreateBrowser(WindowInfo windowInfo, Client client, StringUtf16 url, BrowserSettings settings, jnr.ffi.Pointer requestContext) {
        return INSTANCE.browserHostCreateBrowser(windowInfo, client, url, settings, requestContext);
    }
    
    /**
     * (Not documented)
     * 
     * @method browserHostCreateBrowserSync(windowInfo, client, url, settings, requestContext)
     * @param [WindowInfo] windowInfo 
     * @param [FFI::Pointer(*Client)] client 
     * @param [StringUtf16] url 
     * @param [BrowserSettings] settings 
     * @param [FFI::Pointer(*RequestContext)] requestContext 
     * @return [Browser] 
     * @scope class
     */
    public static Browser browserHostCreateBrowserSync(WindowInfo windowInfo, Client client, StringUtf16 url, BrowserSettings settings, jnr.ffi.Pointer requestContext) {
        return INSTANCE.browserHostCreateBrowserSync(windowInfo, client, url, settings, requestContext);
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :onTakeFocus ::
     *   (Function(OnTakeFocus)) Called when the browser component is about to loose focus. For instance, if
     *   focus was on the last HTML element and the user pressed the TAB key. |next|
     *   will be true (1) if the browser is giving focus to the next component and
     *   false (0) if the browser is giving focus to the previous component.
     * :onSetFocus ::
     *   (Function(OnSetFocus)) Called when the browser component is requesting focus. |source| indicates
     *   where the focus request is originating from. Return false (0) to allow the
     *   focus to be set or true (1) to cancel setting the focus.
     * :onGotFocus ::
     *   (Function(OnGotFocus)) Called when the browser component has received focus.
     */
    public static final class FocusHandler extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<OnTakeFocus> onTakeFocus = function(OnTakeFocus.class);
        public static interface OnTakeFocus {
            @Delegate
            void invoke(jnr.ffi.Pointer focusHandler, jnr.ffi.Pointer browser_1, int int_2);
        }
        public void setOnTakeFocus(OnTakeFocus callback) {
            onTakeFocus.set(callback);
        }
        
        public Function<OnSetFocus> onSetFocus = function(OnSetFocus.class);
        public static interface OnSetFocus {
            @Delegate
            int invoke(jnr.ffi.Pointer focusHandler, jnr.ffi.Pointer browser_1, FocusSource focusSource_2);
        }
        public void setOnSetFocus(OnSetFocus callback) {
            onSetFocus.set(callback);
        }
        
        public Function<OnGotFocus> onGotFocus = function(OnGotFocus.class);
        public static interface OnGotFocus {
            @Delegate
            void invoke(jnr.ffi.Pointer focusHandler, jnr.ffi.Pointer browser_1);
        }
        public void setOnGotFocus(OnGotFocus callback) {
            onGotFocus.set(callback);
        }
        
        public FocusHandler(jnr.ffi.Runtime runtime) {
          super(runtime);
          directMemoryForStruct(this);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :onBeforePopup ::
     *   (Function(OnBeforePopup)) Called on the IO thread before a new popup browser is created. The
     *   |browser| and |frame| values represent the source of the popup request. The
     *   |target_url| and |target_frame_name| values indicate where the popup
     *   browser should navigate and may be NULL if not specified with the request.
     *   The |target_disposition| value indicates where the user intended to open
     *   the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
     *   be true (1) if the popup was opened via explicit user gesture (e.g.
     *   clicking a link) or false (0) if the popup opened automatically (e.g. via
     *   the DomContentLoaded event). The |popupFeatures| structure contains
     *   additional information about the requested popup window. To allow creation
     *   of the popup browser optionally modify |windowInfo|, |client|, |settings|
     *   and |no_javascript_access| and return false (0). To cancel creation of the
     *   popup browser return true (1). The |client| and |settings| values will
     *   default to the source browser's values. If the |no_javascript_access| value
     *   is set to false (0) the new browser will not be scriptable and may not be
     *   hosted in the same renderer process as the source browser. Any
     *   modifications to |windowInfo| will be ignored if the parent browser is
     *   wrapped in a cef_browser_view_t.
     * :onAfterCreated ::
     *   (Function(OnAfterCreated)) Called after a new browser is created. This callback will be the first
     *   notification that references |browser|.
     * :doClose ::
     *   (Function(DoClose)) Called when a browser has recieved a request to close. This may result
     *   directly from a call to cef_browser_host_t::*close_browser() or indirectly
     *   if the browser is parented to a top-level window created by CEF and the
     *   user attempts to close that window (by clicking the 'X', for example). The
     *   do_close() function will be called after the JavaScript 'onunload' event
     *   has been fired.
     *   
     *   An application should handle top-level owner window close notifications by
     *   calling cef_browser_host_t::try_close_browser() or
     *   cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
     *   to close immediately (see the examples below). This gives CEF an
     *   opportunity to process the 'onbeforeunload' event and optionally cancel the
     *   close before do_close() is called.
     *   
     *   When windowed rendering is enabled CEF will internally create a window or
     *   view to host the browser. In that case returning false (0) from do_close()
     *   will send the standard close notification to the browser's top-level owner
     *   window (e.g. WM_CLOSE on Windows, performClose: on OS X, "delete_event" on
     *   Linux or cef_window_delegate_t::can_close() callback from Views). If the
     *   browser's host window/view has already been destroyed (via view hierarchy
     *   tear-down, for example) then do_close() will not be called for that browser
     *   since is no longer possible to cancel the close.
     *   
     *   When windowed rendering is disabled returning false (0) from do_close()
     *   will cause the browser object to be destroyed immediately.
     *   
     *   If the browser's top-level owner window requires a non-standard close
     *   notification then send that notification from do_close() and return true
     *   (1).
     *   
     *   The cef_life_span_handler_t::on_before_close() function will be called
     *   after do_close() (if do_close() is called) and immediately before the
     *   browser object is destroyed. The application should only exit after
     *   on_before_close() has been called for all existing browsers.
     *   
     *   The below examples describe what should happen during window close when the
     *   browser is parented to an application-provided top-level window.
     *   
     *   Example 1: Using cef_browser_host_t::try_close_browser(). This is
     *   recommended for clients using standard close handling and windows created
     *   on the browser process UI thread. 1.  User clicks the window close button
     *   which sends a close notification to
     *       the application's top-level window.
     *   2.  Application's top-level window receives the close notification and
     *       calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
     *       TryCloseBrowser() returns false so the client cancels the window close.
     *   3.  JavaScript 'onbeforeunload' handler executes and shows the close
     *       confirmation dialog (which can be overridden via
     *       CefJSDialogHandler::OnBeforeUnloadDialog()).
     *   4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.
     *   CEF sends a close notification to the application's top-level window
     *       (because DoClose() returned false by default).
     *   7.  Application's top-level window receives the close notification and
     *       calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
     *       allows the window close.
     *   8.  Application's top-level window is destroyed. 9.  Application's
     *   on_before_close() handler is called and the browser object
     *       is destroyed.
     *   10. Application exits by calling cef_quit_message_loop() if no other
     *   browsers
     *       exist.
     *   
     *   Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
     *   implementing the do_close() callback. This is recommended for clients using
     *   non-standard close handling or windows that were not created on the browser
     *   process UI thread. 1.  User clicks the window close button which sends a
     *   close notification to
     *       the application's top-level window.
     *   2.  Application's top-level window receives the close notification and:
     *       A. Calls CefBrowserHost::CloseBrowser(false).
     *       B. Cancels the window close.
     *   3.  JavaScript 'onbeforeunload' handler executes and shows the close
     *       confirmation dialog (which can be overridden via
     *       CefJSDialogHandler::OnBeforeUnloadDialog()).
     *   4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.
     *   Application's do_close() handler is called. Application will:
     *       A. Set a flag to indicate that the next close attempt will be allowed.
     *       B. Return false.
     *   7.  CEF sends an close notification to the application's top-level window.
     *   8.  Application's top-level window receives the close notification and
     *       allows the window to close based on the flag from #6B.
     *   9.  Application's top-level window is destroyed. 10. Application's
     *   on_before_close() handler is called and the browser object
     *       is destroyed.
     *   11. Application exits by calling cef_quit_message_loop() if no other
     *   browsers
     *       exist.
     * :onBeforeClose ::
     *   (Function(OnBeforeClose)) Called just before a browser is destroyed. Release all references to the
     *   browser object and do not attempt to execute any functions on the browser
     *   object after this callback returns. This callback will be the last
     *   notification that references |browser|. See do_close() documentation for
     *   additional usage information.
     */
    public static final class LifeSpanHandler extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<OnBeforePopup> onBeforePopup = function(OnBeforePopup.class);
        public static interface OnBeforePopup {
            @Delegate
            int invoke(jnr.ffi.Pointer lifeSpanHandler, jnr.ffi.Pointer browser_1, jnr.ffi.Pointer frame_2, jnr.ffi.Pointer stringUtf16_3, jnr.ffi.Pointer stringUtf16_4, WindowOpenDisposition windowOpenDisposition_5, int int_6, jnr.ffi.Pointer popupFeatures_7, jnr.ffi.Pointer windowInfo_8, jnr.ffi.Pointer client_9, jnr.ffi.Pointer browserSettings_10, jnr.ffi.Pointer int_11);
        }
        public void setOnBeforePopup(OnBeforePopup callback) {
            onBeforePopup.set(callback);
        }
        
        public Function<OnAfterCreated> onAfterCreated = function(OnAfterCreated.class);
        public static interface OnAfterCreated {
            @Delegate
            void invoke(jnr.ffi.Pointer lifeSpanHandler, jnr.ffi.Pointer browser_1);
        }
        public void setOnAfterCreated(OnAfterCreated callback) {
            onAfterCreated.set(callback);
        }
        
        public Function<DoClose> doClose = function(DoClose.class);
        public static interface DoClose {
            @Delegate
            int invoke(jnr.ffi.Pointer lifeSpanHandler, jnr.ffi.Pointer browser_1);
        }
        public void setDoClose(DoClose callback) {
            doClose.set(callback);
        }
        
        public Function<OnBeforeClose> onBeforeClose = function(OnBeforeClose.class);
        public static interface OnBeforeClose {
            @Delegate
            void invoke(jnr.ffi.Pointer lifeSpanHandler, jnr.ffi.Pointer browser_1);
        }
        public void setOnBeforeClose(OnBeforeClose callback) {
            onBeforeClose.set(callback);
        }
        
        public LifeSpanHandler(jnr.ffi.Runtime runtime) {
          super(runtime);
          directMemoryForStruct(this);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :getContextMenuHandler ::
     *   (Function(GetContextMenuHandler)) Return the handler for context menus. If no handler is provided the default
     *   implementation will be used.
     * :getDialogHandler ::
     *   (Function(GetDialogHandler)) Return the handler for dialogs. If no handler is provided the default
     *   implementation will be used.
     * :getDisplayHandler ::
     *   (Function(GetDisplayHandler)) Return the handler for browser display state events.
     * :getDownloadHandler ::
     *   (Function(GetDownloadHandler)) Return the handler for download events. If no handler is returned downloads
     *   will not be allowed.
     * :getDragHandler ::
     *   (Function(GetDragHandler)) Return the handler for drag events.
     * :getFindHandler ::
     *   (Function(GetFindHandler)) Return the handler for find result events.
     * :getFocusHandler ::
     *   (Function(GetFocusHandler)) Return the handler for focus events.
     * :getGeolocationHandler ::
     *   (Function(GetGeolocationHandler)) Return the handler for geolocation permissions requests. If no handler is
     *   provided geolocation access will be denied by default.
     * :getJsdialogHandler ::
     *   (Function(GetJsdialogHandler)) Return the handler for JavaScript dialogs. If no handler is provided the
     *   default implementation will be used.
     * :getKeyboardHandler ::
     *   (Function(GetKeyboardHandler)) Return the handler for keyboard events.
     * :getLifeSpanHandler ::
     *   (Function(GetLifeSpanHandler)) Return the handler for browser life span events.
     * :getLoadHandler ::
     *   (Function(GetLoadHandler)) Return the handler for browser load status events.
     * :getRenderHandler ::
     *   (Function(GetRenderHandler)) Return the handler for off-screen rendering events.
     * :getRequestHandler ::
     *   (Function(GetRequestHandler)) Return the handler for browser request events.
     * :onProcessMessageReceived ::
     *   (Function(OnProcessMessageReceived)) Called when a new message is received from a different process. Return true
     *   (1) if the message was handled or false (0) otherwise. Do not keep a
     *   reference to or attempt to access the message outside of this callback.
     */
    public static final class Client extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<GetContextMenuHandler> getContextMenuHandler = function(GetContextMenuHandler.class);
        public static interface GetContextMenuHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetContextMenuHandler(GetContextMenuHandler callback) {
            getContextMenuHandler.set(callback);
        }
        
        public Function<GetDialogHandler> getDialogHandler = function(GetDialogHandler.class);
        public static interface GetDialogHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetDialogHandler(GetDialogHandler callback) {
            getDialogHandler.set(callback);
        }
        
        public Function<GetDisplayHandler> getDisplayHandler = function(GetDisplayHandler.class);
        public static interface GetDisplayHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetDisplayHandler(GetDisplayHandler callback) {
            getDisplayHandler.set(callback);
        }
        
        public Function<GetDownloadHandler> getDownloadHandler = function(GetDownloadHandler.class);
        public static interface GetDownloadHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetDownloadHandler(GetDownloadHandler callback) {
            getDownloadHandler.set(callback);
        }
        
        public Function<GetDragHandler> getDragHandler = function(GetDragHandler.class);
        public static interface GetDragHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetDragHandler(GetDragHandler callback) {
            getDragHandler.set(callback);
        }
        
        public Function<GetFindHandler> getFindHandler = function(GetFindHandler.class);
        public static interface GetFindHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetFindHandler(GetFindHandler callback) {
            getFindHandler.set(callback);
        }
        
        public Function<GetFocusHandler> getFocusHandler = function(GetFocusHandler.class);
        public static interface GetFocusHandler {
            @Delegate
            FocusHandler invoke(jnr.ffi.Pointer client);
        }
        public void setGetFocusHandler(GetFocusHandler callback) {
            getFocusHandler.set(callback);
        }
        
        public Function<GetGeolocationHandler> getGeolocationHandler = function(GetGeolocationHandler.class);
        public static interface GetGeolocationHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetGeolocationHandler(GetGeolocationHandler callback) {
            getGeolocationHandler.set(callback);
        }
        
        public Function<GetJsdialogHandler> getJsdialogHandler = function(GetJsdialogHandler.class);
        public static interface GetJsdialogHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetJsdialogHandler(GetJsdialogHandler callback) {
            getJsdialogHandler.set(callback);
        }
        
        public Function<GetKeyboardHandler> getKeyboardHandler = function(GetKeyboardHandler.class);
        public static interface GetKeyboardHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetKeyboardHandler(GetKeyboardHandler callback) {
            getKeyboardHandler.set(callback);
        }
        
        public Function<GetLifeSpanHandler> getLifeSpanHandler = function(GetLifeSpanHandler.class);
        public static interface GetLifeSpanHandler {
            @Delegate
            LifeSpanHandler invoke(jnr.ffi.Pointer client);
        }
        public void setGetLifeSpanHandler(GetLifeSpanHandler callback) {
            getLifeSpanHandler.set(callback);
        }
        
        public Function<GetLoadHandler> getLoadHandler = function(GetLoadHandler.class);
        public static interface GetLoadHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetLoadHandler(GetLoadHandler callback) {
            getLoadHandler.set(callback);
        }
        
        public Function<GetRenderHandler> getRenderHandler = function(GetRenderHandler.class);
        public static interface GetRenderHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetRenderHandler(GetRenderHandler callback) {
            getRenderHandler.set(callback);
        }
        
        public Function<GetRequestHandler> getRequestHandler = function(GetRequestHandler.class);
        public static interface GetRequestHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer client);
        }
        public void setGetRequestHandler(GetRequestHandler callback) {
            getRequestHandler.set(callback);
        }
        
        public Function<OnProcessMessageReceived> onProcessMessageReceived = function(OnProcessMessageReceived.class);
        public static interface OnProcessMessageReceived {
            @Delegate
            int invoke(jnr.ffi.Pointer client, jnr.ffi.Pointer browser_1, ProcessId processId_2, jnr.ffi.Pointer processMessage_3);
        }
        public void setOnProcessMessageReceived(OnProcessMessageReceived callback) {
            onProcessMessageReceived.set(callback);
        }
        
        public Client(jnr.ffi.Runtime runtime) {
          super(runtime);
          directMemoryForStruct(this);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :isValid ::
     *   (Function(IsValid)) Returns true (1) if this object is valid. Do not call any other functions
     *   if this function returns false (0).
     * :isReadOnly ::
     *   (Function(IsReadOnly)) Returns true (1) if the values of this object are read-only. Some APIs may
     *   expose read-only objects.
     * :copy ::
     *   (Function(Copy)) Returns a writable copy of this object.
     * :initFromArgv ::
     *   (Function(InitFromArgv)) Initialize the command line with the specified |argc| and |argv| values.
     *   The first argument must be the name of the program. This function is only
     *   supported on non-Windows platforms.
     * :initFromString ::
     *   (Function(InitFromString)) Initialize the command line with the string returned by calling
     *   GetCommandLineW(). This function is only supported on Windows.
     * :reset ::
     *   (Function(Reset)) Reset the command-line switches and arguments but leave the program
     *   component unchanged.
     * :getArgv ::
     *   (Function(GetArgv)) Retrieve the original command line string as a vector of strings. The argv
     *   array: { program, ((--|-|/)switch(=value))*, (--), (argument)* }
     * :getCommandLineString ::
     *   (Function(GetCommandLineString)) The resulting string must be freed by calling cef_string_userfree_free().
     * :getProgram ::
     *   (Function(GetProgram)) The resulting string must be freed by calling cef_string_userfree_free().
     * :setProgram ::
     *   (Function(SetProgram)) Set the program part of the command line string (the first item).
     * :hasSwitches ::
     *   (Function(HasSwitches)) Returns true (1) if the command line has switches.
     * :hasSwitch ::
     *   (Function(HasSwitch)) Returns true (1) if the command line contains the given switch.
     * :getSwitchValue ::
     *   (Function(GetSwitchValue)) The resulting string must be freed by calling cef_string_userfree_free().
     * :getSwitches ::
     *   (Function(GetSwitches)) Returns the map of switch names and values. If a switch has no value an
     *   NULL string is returned.
     * :appendSwitch ::
     *   (Function(AppendSwitch)) Add a switch to the end of the command line. If the switch has no value
     *   pass an NULL value string.
     * :appendSwitchWithValue ::
     *   (Function(AppendSwitchWithValue)) Add a switch with the specified value to the end of the command line.
     * :hasArguments ::
     *   (Function(HasArguments)) True if there are remaining command line arguments.
     * :getArguments ::
     *   (Function(GetArguments)) Get the remaining command line arguments.
     * :appendArgument ::
     *   (Function(AppendArgument)) Add an argument to the end of the command line.
     * :prependWrapper ::
     *   (Function(PrependWrapper)) Insert a command before the current command. Common for debuggers, like
     *   "valgrind" or "gdb --args".
     */
    public static final class CommandLine extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<IsValid> isValid = function(IsValid.class);
        public static interface IsValid {
            @Delegate
            int invoke(jnr.ffi.Pointer commandLine);
        }
        public void setIsValid(IsValid callback) {
            isValid.set(callback);
        }
        
        public Function<IsReadOnly> isReadOnly = function(IsReadOnly.class);
        public static interface IsReadOnly {
            @Delegate
            int invoke(jnr.ffi.Pointer commandLine);
        }
        public void setIsReadOnly(IsReadOnly callback) {
            isReadOnly.set(callback);
        }
        
        public Function<Copy> copy = function(Copy.class);
        public static interface Copy {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer commandLine);
        }
        public void setCopy(Copy callback) {
            copy.set(callback);
        }
        
        public Function<InitFromArgv> initFromArgv = function(InitFromArgv.class);
        public static interface InitFromArgv {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, int int_1, jnr.ffi.Pointer charS_2);
        }
        public void setInitFromArgv(InitFromArgv callback) {
            initFromArgv.set(callback);
        }
        
        public Function<InitFromString> initFromString = function(InitFromString.class);
        public static interface InitFromString {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setInitFromString(InitFromString callback) {
            initFromString.set(callback);
        }
        
        public Function<Reset> reset = function(Reset.class);
        public static interface Reset {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine);
        }
        public void setReset(Reset callback) {
            reset.set(callback);
        }
        
        public Function<GetArgv> getArgv = function(GetArgv.class);
        public static interface GetArgv {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer void_1);
        }
        public void setGetArgv(GetArgv callback) {
            getArgv.set(callback);
        }
        
        public Function<GetCommandLineString> getCommandLineString = function(GetCommandLineString.class);
        public static interface GetCommandLineString {
            @Delegate
            StringUtf16 invoke(jnr.ffi.Pointer commandLine);
        }
        public void setGetCommandLineString(GetCommandLineString callback) {
            getCommandLineString.set(callback);
        }
        
        public Function<GetProgram> getProgram = function(GetProgram.class);
        public static interface GetProgram {
            @Delegate
            StringUtf16 invoke(jnr.ffi.Pointer commandLine);
        }
        public void setGetProgram(GetProgram callback) {
            getProgram.set(callback);
        }
        
        public Function<SetProgram> setProgram = function(SetProgram.class);
        public static interface SetProgram {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setSetProgram(SetProgram callback) {
            setProgram.set(callback);
        }
        
        public Function<HasSwitches> hasSwitches = function(HasSwitches.class);
        public static interface HasSwitches {
            @Delegate
            int invoke(jnr.ffi.Pointer commandLine);
        }
        public void setHasSwitches(HasSwitches callback) {
            hasSwitches.set(callback);
        }
        
        public Function<HasSwitch> hasSwitch = function(HasSwitch.class);
        public static interface HasSwitch {
            @Delegate
            int invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setHasSwitch(HasSwitch callback) {
            hasSwitch.set(callback);
        }
        
        public Function<GetSwitchValue> getSwitchValue = function(GetSwitchValue.class);
        public static interface GetSwitchValue {
            @Delegate
            StringUtf16 invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setGetSwitchValue(GetSwitchValue callback) {
            getSwitchValue.set(callback);
        }
        
        public Function<GetSwitches> getSwitches = function(GetSwitches.class);
        public static interface GetSwitches {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer void_1);
        }
        public void setGetSwitches(GetSwitches callback) {
            getSwitches.set(callback);
        }
        
        public Function<AppendSwitch> appendSwitch = function(AppendSwitch.class);
        public static interface AppendSwitch {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setAppendSwitch(AppendSwitch callback) {
            appendSwitch.set(callback);
        }
        
        public Function<AppendSwitchWithValue> appendSwitchWithValue = function(AppendSwitchWithValue.class);
        public static interface AppendSwitchWithValue {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1, jnr.ffi.Pointer stringUtf16_2);
        }
        public void setAppendSwitchWithValue(AppendSwitchWithValue callback) {
            appendSwitchWithValue.set(callback);
        }
        
        public Function<HasArguments> hasArguments = function(HasArguments.class);
        public static interface HasArguments {
            @Delegate
            int invoke(jnr.ffi.Pointer commandLine);
        }
        public void setHasArguments(HasArguments callback) {
            hasArguments.set(callback);
        }
        
        public Function<GetArguments> getArguments = function(GetArguments.class);
        public static interface GetArguments {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer void_1);
        }
        public void setGetArguments(GetArguments callback) {
            getArguments.set(callback);
        }
        
        public Function<AppendArgument> appendArgument = function(AppendArgument.class);
        public static interface AppendArgument {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setAppendArgument(AppendArgument callback) {
            appendArgument.set(callback);
        }
        
        public Function<PrependWrapper> prependWrapper = function(PrependWrapper.class);
        public static interface PrependWrapper {
            @Delegate
            void invoke(jnr.ffi.Pointer commandLine, jnr.ffi.Pointer stringUtf16_1);
        }
        public void setPrependWrapper(PrependWrapper callback) {
            prependWrapper.set(callback);
        }
        
        public CommandLine(jnr.ffi.Runtime runtime) {
          super(runtime);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * (Not documented)
     * 
     * @method commandLineCreate()
     * @return [CommandLine] 
     * @scope class
     */
    public static CommandLine commandLineCreate() {
        return INSTANCE.commandLineCreate();
    }
    
    /**
     * (Not documented)
     * 
     * @method commandLineGetGlobal()
     * @return [CommandLine] 
     * @scope class
     */
    public static CommandLine commandLineGetGlobal() {
        return INSTANCE.commandLineGetGlobal();
    }
    
    /**
     * (Not documented)
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :onContextInitialized ::
     *   (Function(OnContextInitialized)) Called on the browser process UI thread immediately after the CEF context
     *   has been initialized.
     * :onBeforeChildProcessLaunch ::
     *   (Function(OnBeforeChildProcessLaunch)) Called before a child process is launched. Will be called on the browser
     *   process UI thread when launching a render process and on the browser
     *   process IO thread when launching a GPU or plugin process. Provides an
     *   opportunity to modify the child process command line. Do not keep a
     *   reference to |command_line| outside of this function.
     * :onRenderProcessThreadCreated ::
     *   (Function(OnRenderProcessThreadCreated)) Called on the browser process IO thread after the main thread has been
     *   created for a new render process. Provides an opportunity to specify extra
     *   information that will be passed to
     *   cef_render_process_handler_t::on_render_thread_created() in the render
     *   process. Do not keep a reference to |extra_info| outside of this function.
     * :getPrintHandler ::
     *   (Function(GetPrintHandler)) Return the handler for printing on Linux. If a print handler is not
     *   provided then printing will not be supported on the Linux platform.
     * :onScheduleMessagePumpWork ::
     *   (Function(OnScheduleMessagePumpWork)) Called from any thread when work has been scheduled for the browser process
     *   main (UI) thread. This callback is used in combination with CefSettings.
     *   external_message_pump and cef_do_message_loop_work() in cases where the CEF
     *   message loop must be integrated into an existing application message loop
     *   (see additional comments and warnings on CefDoMessageLoopWork). This
     *   callback should schedule a cef_do_message_loop_work() call to happen on the
     *   main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
     *   |delay_ms| is <= 0 then the call should happen reasonably soon. If
     *   |delay_ms| is > 0 then the call should be scheduled to happen after the
     *   specified delay and any currently pending scheduled call should be
     *   cancelled.
     */
    public static final class BrowserProcessHandler extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<OnContextInitialized> onContextInitialized = function(OnContextInitialized.class);
        public static interface OnContextInitialized {
            @Delegate
            void invoke(jnr.ffi.Pointer browserProcessHandler);
        }
        public void setOnContextInitialized(OnContextInitialized callback) {
            onContextInitialized.set(callback);
        }
        
        public Function<OnBeforeChildProcessLaunch> onBeforeChildProcessLaunch = function(OnBeforeChildProcessLaunch.class);
        public static interface OnBeforeChildProcessLaunch {
            @Delegate
            void invoke(jnr.ffi.Pointer browserProcessHandler, jnr.ffi.Pointer commandLine_1);
        }
        public void setOnBeforeChildProcessLaunch(OnBeforeChildProcessLaunch callback) {
            onBeforeChildProcessLaunch.set(callback);
        }
        
        public Function<OnRenderProcessThreadCreated> onRenderProcessThreadCreated = function(OnRenderProcessThreadCreated.class);
        public static interface OnRenderProcessThreadCreated {
            @Delegate
            void invoke(jnr.ffi.Pointer browserProcessHandler, jnr.ffi.Pointer listValue_1);
        }
        public void setOnRenderProcessThreadCreated(OnRenderProcessThreadCreated callback) {
            onRenderProcessThreadCreated.set(callback);
        }
        
        public Function<GetPrintHandler> getPrintHandler = function(GetPrintHandler.class);
        public static interface GetPrintHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer browserProcessHandler);
        }
        public void setGetPrintHandler(GetPrintHandler callback) {
            getPrintHandler.set(callback);
        }
        
        public Function<OnScheduleMessagePumpWork> onScheduleMessagePumpWork = function(OnScheduleMessagePumpWork.class);
        public static interface OnScheduleMessagePumpWork {
            @Delegate
            void invoke(jnr.ffi.Pointer browserProcessHandler, long long_1);
        }
        public void setOnScheduleMessagePumpWork(OnScheduleMessagePumpWork callback) {
            onScheduleMessagePumpWork.set(callback);
        }
        
        public BrowserProcessHandler(jnr.ffi.Runtime runtime) {
          super(runtime);
          directMemoryForStruct(this);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * Implement this structure to provide handler implementations. Methods will be
     * called by the process and/or thread indicated.
     * 
     * = Fields:
     * :base ::
     *   (BaseRefCounted) Base structure.
     * :onBeforeCommandLineProcessing ::
     *   (Function(OnBeforeCommandLineProcessing)) Provides an opportunity to view and/or modify command-line arguments before
     *   processing by CEF and Chromium. The |process_type| value will be NULL for
     *   the browser process. Do not keep a reference to the cef_command_line_t
     *   object passed to this function. The CefSettings.command_line_args_disabled
     *   value can be used to start with an NULL command-line object. Any values
     *   specified in CefSettings that equate to command-line arguments will be set
     *   before this function is called. Be cautious when using this function to
     *   modify command-line arguments for non-browser processes as this may result
     *   in undefined behavior including crashes.
     * :onRegisterCustomSchemes ::
     *   (Function(OnRegisterCustomSchemes)) Provides an opportunity to register custom schemes. Do not keep a reference
     *   to the |registrar| object. This function is called on the main thread for
     *   each process and the registered schemes should be the same across all
     *   processes.
     * :getResourceBundleHandler ::
     *   (Function(GetResourceBundleHandler)) Return the handler for resource bundle events. If
     *   CefSettings.pack_loading_disabled is true (1) a handler must be returned.
     *   If no handler is returned resources will be loaded from pack files. This
     *   function is called by the browser and render processes on multiple threads.
     * :getBrowserProcessHandler ::
     *   (Function(GetBrowserProcessHandler)) Return the handler for functionality specific to the browser process. This
     *   function is called on multiple threads in the browser process.
     * :getRenderProcessHandler ::
     *   (Function(GetRenderProcessHandler)) Return the handler for functionality specific to the render process. This
     *   function is called on the render process main thread.
     */
    public static final class App extends Struct {
        public BaseRefCounted base = inner(new BaseRefCounted(getRuntime()));
        public Function<OnBeforeCommandLineProcessing> onBeforeCommandLineProcessing = function(OnBeforeCommandLineProcessing.class);
        public static interface OnBeforeCommandLineProcessing {
            @Delegate
            void invoke(jnr.ffi.Pointer app, jnr.ffi.Pointer stringUtf16_1, jnr.ffi.Pointer commandLine_2);
        }
        public void setOnBeforeCommandLineProcessing(OnBeforeCommandLineProcessing callback) {
            onBeforeCommandLineProcessing.set(callback);
        }
        
        public Function<OnRegisterCustomSchemes> onRegisterCustomSchemes = function(OnRegisterCustomSchemes.class);
        public static interface OnRegisterCustomSchemes {
            @Delegate
            void invoke(jnr.ffi.Pointer app, jnr.ffi.Pointer schemeRegistrar_1);
        }
        public void setOnRegisterCustomSchemes(OnRegisterCustomSchemes callback) {
            onRegisterCustomSchemes.set(callback);
        }
        
        public Function<GetResourceBundleHandler> getResourceBundleHandler = function(GetResourceBundleHandler.class);
        public static interface GetResourceBundleHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer app);
        }
        public void setGetResourceBundleHandler(GetResourceBundleHandler callback) {
            getResourceBundleHandler.set(callback);
        }
        
        public Function<GetBrowserProcessHandler> getBrowserProcessHandler = function(GetBrowserProcessHandler.class);
        public static interface GetBrowserProcessHandler {
            @Delegate
            BrowserProcessHandler invoke(jnr.ffi.Pointer app);
        }
        public void setGetBrowserProcessHandler(GetBrowserProcessHandler callback) {
            getBrowserProcessHandler.set(callback);
        }
        
        public Function<GetRenderProcessHandler> getRenderProcessHandler = function(GetRenderProcessHandler.class);
        public static interface GetRenderProcessHandler {
            @Delegate
            jnr.ffi.Pointer invoke(jnr.ffi.Pointer app);
        }
        public void setGetRenderProcessHandler(GetRenderProcessHandler callback) {
            getRenderProcessHandler.set(callback);
        }
        
        public App(jnr.ffi.Runtime runtime) {
          super(runtime);
          directMemoryForStruct(this);
          base.setFns();
          base.setSize(this);
        }
    }
    
    /**
     * This function should be called from the application entry point function to
     * execute a secondary process. It can be used to run secondary processes from
     * the browser client executable (default behavior) or from a separate
     * executable specified by the CefSettings.browser_subprocess_path value. If
     * called for the browser process (identified by no "type" command-line value)
     * it will return immediately with a value of -1. If called for a recognized
     * secondary process it will block until the process should exit and then return
     * the process exit code. The |application| parameter may be NULL. The
     * |windows_sandbox_info| parameter is only used on Windows and may be NULL (see
     * cef_sandbox_win.h for details).
     * 
     * @method executeProcess(args, application, windowsSandboxInfo)
     * @param [MainArgs] args 
     * @param [App] application 
     * @param [FFI::Pointer(*Void)] windowsSandboxInfo 
     * @return [Integer] 
     * @scope class
     */
    public static int executeProcess(MainArgs args, App application, jnr.ffi.Pointer windowsSandboxInfo) {
        return INSTANCE.executeProcess(args, application, windowsSandboxInfo);
    }
    
    /**
     * This function should be called on the main application thread to initialize
     * the CEF browser process. The |application| parameter may be NULL. A return
     * value of true (1) indicates that it succeeded and false (0) indicates that it
     * failed. The |windows_sandbox_info| parameter is only used on Windows and may
     * be NULL (see cef_sandbox_win.h for details).
     * 
     * @method initialize(args, settings, application, windowsSandboxInfo)
     * @param [MainArgs] args 
     * @param [Settings] settings 
     * @param [App] application 
     * @param [FFI::Pointer(*Void)] windowsSandboxInfo 
     * @return [Integer] 
     * @scope class
     */
    public static int initialize(MainArgs args, Settings settings, App application, jnr.ffi.Pointer windowsSandboxInfo) {
        return INSTANCE.initialize(args, settings, application, windowsSandboxInfo);
    }
    
    /**
     * This function should be called on the main application thread to shut down
     * the CEF browser process before the application exits.
     * 
     * @method shutdown()
     * @return [nil] 
     * @scope class
     */
    public static void shutdown() {
        INSTANCE.shutdown();
    }
    
    /**
     * Perform a single iteration of CEF message loop processing. This function is
     * provided for cases where the CEF message loop must be integrated into an
     * existing application message loop. Use of this function is not recommended
     * for most users; use either the cef_run_message_loop() function or
     * CefSettings.multi_threaded_message_loop if possible. When using this function
     * care must be taken to balance performance against excessive CPU usage. It is
     * recommended to enable the CefSettings.external_message_pump option when using
     * this function so that
     * cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can
     * facilitate the scheduling process. This function should only be called on the
     * main application thread and only if cef_initialize() is called with a
     * CefSettings.multi_threaded_message_loop value of false (0). This function
     * will not block.
     * 
     * @method doMessageLoopWork()
     * @return [nil] 
     * @scope class
     */
    public static void doMessageLoopWork() {
        INSTANCE.doMessageLoopWork();
    }
    
    /**
     * Run the CEF message loop. Use this function instead of an application-
     * provided message loop to get the best balance between performance and CPU
     * usage. This function should only be called on the main application thread and
     * only if cef_initialize() is called with a
     * CefSettings.multi_threaded_message_loop value of false (0). This function
     * will block until a quit message is received by the system.
     * 
     * @method runMessageLoop()
     * @return [nil] 
     * @scope class
     */
    public static void runMessageLoop() {
        INSTANCE.runMessageLoop();
    }
    
    /**
     * Quit the CEF message loop that was started by calling cef_run_message_loop().
     * This function should only be called on the main application thread and only
     * if cef_run_message_loop() was used.
     * 
     * @method quitMessageLoop()
     * @return [nil] 
     * @scope class
     */
    public static void quitMessageLoop() {
        INSTANCE.quitMessageLoop();
    }
    
    /**
     * Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a
     * modal message loop. Set to false (0) after exiting the modal message loop.
     * 
     * @method setOsmodalLoop(osModalLoop)
     * @param [Integer] osModalLoop 
     * @return [nil] 
     * @scope class
     */
    public static void setOsmodalLoop(int osModalLoop) {
        INSTANCE.setOsmodalLoop(osModalLoop);
    }
    
    /**
     * Call during process startup to enable High-DPI support on Windows 7 or newer.
     * Older versions of Windows should be left DPI-unaware because they do not
     * support DirectWrite and GDI fonts are kerned very badly.
     * 
     * @method enableHighdpiSupport()
     * @return [nil] 
     * @scope class
     */
    public static void enableHighdpiSupport() {
        INSTANCE.enableHighdpiSupport();
    }
    
    
    /** 
     * This is required to return struct in callback and to create native memory.
     * @param struct
     */
    static void directMemoryForStruct(Struct struct) {
        Struct.getMemory(struct, ParameterFlags.DIRECT);
	}

	public interface CEFInterface {
        
        @Retention(RetentionPolicy.RUNTIME)
        @Target(ElementType.METHOD)
        @interface NativeName {
            String value();
        }
        
        class NativeNameAnnotationFunctionMapper implements FunctionMapper {
            @Override
            public String mapFunctionName(String functionName, Context context) {
                for (Annotation ann : context.getAnnotations()) {
                    if (ann.annotationType() == NativeName.class)
                        return ((NativeName) ann).value();
                }
                return functionName;
            }
        }
        
        
        static class InstanceCreator {
            private static CEFInterface createInstance() {
                boolean isWin = System.getProperty("os.name").toLowerCase().contains("win");
                boolean isMac = System.getProperty("os.name").toLowerCase().contains("mac");
                String toLoad = "cef";
                String cefrustPath = System.getProperty("cefswt.path", "");
                if (isWin) {
                    toLoad = "libcef";
            	} else if (isMac) {
                    toLoad = cefrustPath + "/Chromium Embedded Framework.framework/Chromium Embedded Framework";
                } else {
                	toLoad = cefrustPath + "/libcef.so";
                }

                CEFInterface lib = LibraryLoader.create(CEFInterface.class)
                  .option(LibraryOption.FunctionMapper, new NativeNameAnnotationFunctionMapper())
                  .map(StringUtf8.class, new InnerStructToNativeConverter())
                  .map(StringUtf16.class, new InnerStructToNativeConverter())
                  .load(toLoad);
                RUNTIME = jnr.ffi.Runtime.getRuntime(lib);
                return lib;
            }
        }
        
        @NativeName("cef_string_wide_set")
        int stringWideSet(jnr.ffi.Pointer src, long srcLen, StringWide output, int copy);
        
        @NativeName("cef_string_utf8_set")
        int stringUtf8Set(String src, long srcLen, StringUtf8 output, int copy);
        
        @NativeName("cef_string_utf16_set")
        int stringUtf16Set(jnr.ffi.Pointer src, long srcLen, StringUtf16 output, int copy);
        
        @NativeName("cef_string_wide_clear")
        void stringWideClear(StringWide str);
        
        @NativeName("cef_string_utf8_clear")
        void stringUtf8Clear(StringUtf8 str);
        
        @NativeName("cef_string_utf16_clear")
        void stringUtf16Clear(StringUtf16 str);
        
        @NativeName("cef_string_wide_cmp")
        int stringWideCmp(StringWide str1, StringWide str2);
        
        @NativeName("cef_string_utf8_cmp")
        int stringUtf8Cmp(StringUtf8 str1, StringUtf8 str2);
        
        @NativeName("cef_string_utf16_cmp")
        int stringUtf16Cmp(StringUtf16 str1, StringUtf16 str2);
        
        @NativeName("cef_string_wide_to_utf8")
        int stringWideToUtf8(jnr.ffi.Pointer src, long srcLen, StringUtf8 output);
        
        @NativeName("cef_string_utf8_to_wide")
        int stringUtf8ToWide(String src, long srcLen, StringWide output);
        
        @NativeName("cef_string_wide_to_utf16")
        int stringWideToUtf16(jnr.ffi.Pointer src, long srcLen, StringUtf16 output);
        
        @NativeName("cef_string_utf16_to_wide")
        int stringUtf16ToWide(jnr.ffi.Pointer src, long srcLen, StringWide output);
        
        @NativeName("cef_string_utf8_to_utf16")
        int stringUtf8ToUtf16(String src, long srcLen, StringUtf16 output);
        
        @NativeName("cef_string_utf16_to_utf8")
        int stringUtf16ToUtf8(jnr.ffi.Pointer src, long srcLen, StringUtf8 output);
        
        @NativeName("cef_string_ascii_to_wide")
        int stringAsciiToWide(String src, long srcLen, StringWide output);
        
        @NativeName("cef_string_ascii_to_utf16")
        int stringAsciiToUtf16(String src, long srcLen, StringUtf16 output);
        
        @NativeName("cef_string_userfree_wide_alloc")
        StringWide stringUserfreeWideAlloc();
        
        @NativeName("cef_string_userfree_utf8_alloc")
        StringUtf8 stringUserfreeUtf8Alloc();
        
        @NativeName("cef_string_userfree_utf16_alloc")
        StringUtf16 stringUserfreeUtf16Alloc();
        
        @NativeName("cef_string_userfree_wide_free")
        void stringUserfreeWideFree(StringWide str);
        
        @NativeName("cef_string_userfree_utf8_free")
        void stringUserfreeUtf8Free(StringUtf8 str);
        
        @NativeName("cef_string_userfree_utf16_free")
        void stringUserfreeUtf16Free(StringUtf16 str);
        
        @NativeName("cef_string_utf16_to_lower")
        int stringUtf16ToLower(jnr.ffi.Pointer src, long srcLen, StringUtf16 output);
        
        @NativeName("cef_string_utf16_to_upper")
        int stringUtf16ToUpper(jnr.ffi.Pointer src, long srcLen, StringUtf16 output);
        
        @NativeName("cef_get_xdisplay")
        XDisplay getXdisplay();
        
        @NativeName("cef_browser_host_create_browser")
        int browserHostCreateBrowser(WindowInfo windowInfo, Client client, StringUtf16 url, BrowserSettings settings, jnr.ffi.Pointer requestContext);
        
        @NativeName("cef_browser_host_create_browser_sync")
        Browser browserHostCreateBrowserSync(WindowInfo windowInfo, Client client, StringUtf16 url, BrowserSettings settings, jnr.ffi.Pointer requestContext);
        
        @NativeName("cef_command_line_create")
        CommandLine commandLineCreate();
        
        @NativeName("cef_command_line_get_global")
        CommandLine commandLineGetGlobal();
        
        @NativeName("cef_execute_process")
        int executeProcess(MainArgs args, App application, jnr.ffi.Pointer windowsSandboxInfo);
        
        @NativeName("cef_initialize")
        int initialize(MainArgs args, Settings settings, App application, jnr.ffi.Pointer windowsSandboxInfo);
        
        @NativeName("cef_shutdown")
        void shutdown();
        
        @NativeName("cef_do_message_loop_work")
        void doMessageLoopWork();
        
        @NativeName("cef_run_message_loop")
        void runMessageLoop();
        
        @NativeName("cef_quit_message_loop")
        void quitMessageLoop();
        
        @NativeName("cef_set_osmodal_loop")
        void setOsmodalLoop(int osModalLoop);
        
        @NativeName("cef_enable_highdpi_support")
        void enableHighdpiSupport();
        
    }
}
